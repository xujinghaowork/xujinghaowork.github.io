<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[个人微信小小程序的搭建]]></title>
    <url>%2F2018%2F06%2F28%2F2018-06-28-%E4%B8%AA%E4%BA%BA%E5%BE%AE%E4%BF%A1%E5%B0%8F%E5%B0%8F%E7%A8%8B%E5%BA%8F%E7%9A%84%E6%90%AD%E5%BB%BA%2F</url>
    <content type="text"><![CDATA[前言虽然现在学习微信小程序晚了些，但是还是要了解一些东西的。没人教的话只能自己去摸索一些东西，而且只能根据一些基础的东西去完成一个demo，并且没有连接到后台QAQ。 下面就是我搭建个人的一个垃圾小程序的过程。 正文工作准备微信开发者工具微信小程序作为一个独立的一套编程体系，是需要用一个配套的编辑器进行开发的，这里特指的就是微信开发者工具 主要外观是这样的 其余的功能和界面可以在微信小程序的官方文档中查看到。 申请微信小程序的开发在微信公众平台中申请账号，可以用QQ以及微信注册，注册之后，点击小程序开发，根据操作设置相关的东西。与编写小程序相关的东西需要记住的为小程序的APPID，在之后创建本地小程序的时候需要用到。 未完待续~~]]></content>
      <tags>
        <tag>微信小程序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CSS实现背景边框效果]]></title>
    <url>%2F2018%2F05%2F02%2F2018-05-02-CSS%E5%AE%9E%E7%8E%B0%E8%83%8C%E6%99%AF%E8%BE%B9%E6%A1%86%E6%95%88%E6%9E%9C%2F</url>
    <content type="text"><![CDATA[前言再漂亮的设计，也可以拆解成基础效果的组合，在这里把一些常用的效果进行了罗列，并附加代码 本文来自掘金社区maodayeyeye用最短的CSS样式，勾勒大数据演示屏 正文优雅的呈现 蒙版文字覆盖一层蒙版，并在蒙版上书写文字。需要2层，从低到上为图片层、蒙版层(上面可写字) 123456789101112131415161718192021222324252627&lt;div class='box'&gt; &lt;div class='back'&gt;&lt;/div&gt; &lt;div class='modal'&gt;&lt;/div&gt; &lt;/div&gt;&lt;style&gt; .box&#123; position: relative; height: 200px; width: 300px &#125; .back&#123; background-image: url(http://www.imaoda.com/s/img/github/21.jpg); height: 100%; width: 100%; &#125; .modal, .desc&#123; position:absolute; height: 20%; width: 100%; bottom: 0; color: white; &#125; .modal&#123; background: rgba(0,0,0,.5) &#125;&lt;/style&gt; 毛玻璃蒙版毛玻璃蒙版，本质上讲是两层图，底层图清晰完整，顶层图模糊残缺，并且两者位移完全一致，因此叠加到一起后像是一张图。为了确保位移一致，我们用了 background : fixed ，他能使背景图片相对于浏览器进行固定。 1234567891011121314151617181920212223&lt;div class='box'&gt; &lt;div class='blur-modal'&gt;&lt;/div&gt; &lt;div class='black-modal'&gt;描述文字&lt;/div&gt; &lt;/div&gt;&lt;style&gt; .box&#123; position: relative; height:200px; width:300px; background: fixed url(http://www.imaoda.com/s/img/github/21.jpg); &#125; .blur-modal&#123; position: absolute; height:50px; width:300px; top: 150px; background: fixed url(http://www.imaoda.com/s/img/github/21.jpg); filter:blur(1rem) &#125; .black-modal&#123; position: absolute; height:50px; width:300px; top: 150px; background: rgba(0,0,0,.2); color: white &#125;&lt;/style&gt; 高斯模糊背景图电影介绍的时候，其背景色跟海报差不多，其实就是放大了海报的一个角落 + 高斯模糊 + 黑色半透明蒙版的效果 12345678910111213141516171819202122&lt;div class='suit'&gt; &lt;div class='figure'&gt;&lt;/div&gt; &lt;div class='modal'&gt;功夫熊猫&lt;/div&gt; &lt;/div&gt;&lt;style&gt; .suit&#123; position: relative; &#125; .figure&#123; background: url(http://www.imaoda.com/s/img/github/21.jpg); background-size: 200%; height: 200px; width: 400px; filter: blur(16px) &#125; .modal&#123; position: absolute; height: 200px; width: 400px; top: 0px; left: 0px; background: rgba(0,0,0,.5); color: white; text-align: center &#125;&lt;/style&gt; filter 的还有一个特效是能让图像在边缘地带跟背景很自然的过渡到一块去 图片边框过去做背景边框，div嵌套，外层的背景用图片，内层略小居中，但这种方法需要精准度量。更方便的方法是使用 border-image 1234567891011121314151617&lt;div class='back'&gt; 运行状态监控 &lt;/div&gt;&lt;style&gt; body&#123; background: #003366; &#125; .back&#123; height: 180px;width: 400px; background: url(http://www.imaoda.com/s/img/tpl/content-frame1.png) no-repeat; background-size: contain; background-position: center; color: white; text-align: center; &#125;&lt;/style&gt; 科技感内发光边框边框内发光可以带来一种 未来科技感（配上动画效果更棒） 1234567891011121314&lt;div class='box'&gt; 数据总览 &lt;/div&gt;&lt;style&gt; body&#123; background: black;padding: 10px &#125; .back&#123; height: 20rem; width: 40rem; color:white; padding: 1rem; box-shadow: 0 0 3rem rgba(100,200,255,.5) inset; background: rgba(0,0,0,.3) &#125;&lt;/style&gt; 科技感图片边框 border-image 的 5% 决定了边框的厚度 123456789101112131415&lt;div class='panel'&gt;正常&lt;/div&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;div class='panel'&gt;外发光&lt;/div&gt;&lt;style&gt; .panel&#123; height: 10rem; width: 20rem; color:rgba(255,255,255,.9); border: 20px solid transparent; border-image: url(http://www.imaoda.com/s/img/tpl/border.png) 5%; background:rgba(0,0,0,.3); &#125; .panel:last-child&#123; box-shadow: 0 0 5rem rgb(0,110,150) &#125;&lt;/style&gt; 科技感图片边框2 123456789101112&lt;div class='box'&gt;正常&lt;/div&gt;&lt;style&gt; body&#123; background: rgb(22,22,22); padding:10rem &#125; .box&#123; height: 10rem; width: 30rem; border: 1.5rem solid transparent; border-image: url(http://www.imaoda.com/s/img/tpl/border1.png) 15% 5%; &#125;&lt;/style&gt; 聚光效果 一个外放光的圆形 border 逐渐缩小的动画： 外层固定大小，采用flex布局确定内层绝对居中对长宽进行动画 border-radius: 50% 百分比固定，保持圆形 1234567891011121314151617181920212223242526272829&lt;div class='box'&gt; &lt;div class='circle'&gt;&lt;/div&gt; &lt;div class='btn'&gt;开始&lt;/div&gt;&lt;/div&gt;&lt;style&gt; .box&#123; position: relative; height: 300px; width: 300px; display: flex; justify-content: center; align-items: center; &#125; .circle&#123; height: 200px; width: 200px; border-radius: 50%; border: 10px solid yellow; filter: drop-shadow(0 0 10px white); animation: shrink 1s infinite; &#125; .btn&#123; position: absolute; top: 50%; left: 50%; transform: translate(-50%,-50%); padding:3rem; background:green; color: white; border-radius: 50%; &#125; @keyframes shrink&#123; 100%&#123; height: 10px; width: 10px; &#125; &#125;&lt;/style&gt; 亮框提示用户点击或者 hover 的时候，边框高亮、发光，以起到提示作用 12345678910111213141516171819202122232425&lt;ul&gt; &lt;li&gt;&lt;/li&gt; &lt;li&gt;&lt;/li&gt; &lt;li&gt;&lt;/li&gt;&lt;/ul&gt;&lt;style&gt; li&#123; display: inline-block; height: 200px; width: 150px; background: url(http://www.imaoda.com/s/img/github/sgs.jpg); background-size: 100%; box-shadow: 0 2px 2px #222222; border: 2px solid transparent; border-radius: 5px; filter: brightness(.7); cursor: pointer; transition: all .2s &#125; li:hover&#123; box-shadow: 0 0 30px yellow; border: 2px solid yellow; transform: translate(0,-10%); filter: brightness(1); &#125;&lt;/style&gt;]]></content>
      <categories>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Vue常见问题01]]></title>
    <url>%2F2018%2F04%2F27%2F2018-04-27-Vue.%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[前言本文主要总结了vue实际开发项目当中应该如何解决一些实际的开发问题，可能你认为很简单，但短时间内也许你并没解决思路的。 本文来自达摩兵的空间博客 正文 for循环中针对ui样式的特征性样式或者事件这种对数据的要求比较高，且要求你能够找到比较好的对应关系，需要针对class进行特征性的组件渲染。当你需要改变时改变数据即可重新渲染达到改变样式的目的。 123456789101112131415161718&lt;li v-for="item of list" :key="item.id" :class="item.status？'color':''" @click="changeColor(item.id)"&gt;&#123;&#123;item.name&#125;&#125;&lt;/li&gt;return &#123; list:[ &#123;id:1,status:true,name:1111&#125;, &#123;id:2,status:true,name:222&#125;] &#125; methods:&#123; changeColor(id)&#123; this.list.map((item)=&gt;&#123; if(item.id==id)&#123; item.status=!item.status; &#125; return item; &#125;) &#125; &#125; 传入对应的参数以及事件源，可以进行相应的判断改变class 特点更加灵活，也可以根据需要传入你需要传入的item属性参数进行与class的匹配判断，不用改变接口返回的数据结构。 1234567891011121314151617&lt;li v-for="item of list" :key="item.id" @click="changeColor($event)"&gt;&#123;&#123;item.name&#125;&#125;&lt;/li&gt;return &#123; list:[ &#123;id:1,name:1111&#125;, &#123;id:2,name:222&#125;] &#125; changeColor(e)&#123; let el=e.target; if(el.classList.contains("color"))&#123; el.classList.remove("color") &#125;else&#123; el.classList.add("color") &#125; &#125; &#125; 计算属性方法的使用问题描述：如果你的计算属性依赖于data的部分，而你的data对应的字段在data里没有申明，只是在请求接口时进行申明赋值，那么当接口请求时，虽然数据发生了变化，但是计算属性的值不会发生更新。 解决方案 ：需要你在data里申明你计算属性依赖的字段，哪怕是空或者null 事件执行顺序问题解决方案:1 常规方案 ： 需要吧点击事件变成@mousedown.prevent ，前者会让点击优于blur执行，后者会阻止blur执行 2 el-input并不生效，可以用计时器延迟执行 将失去焦点的事件计时器延迟执行，然后点击事件里清除定时器，也是可以只执行点击事件逻辑的 路由参数变化组件不更新问题描述 ：路由参数变化，但是组件没有对应的更新，主要是因为一般获取参数写在了created路由钩子函数中，路由参数变化的时候，这个生命周期不会重新执行。 解决方案：watch监听router 1234567891011121314watch: &#123;// 方法1 &apos;$route&apos; (to, from) &#123; //监听路由是否变化 if(this.$route.params.articleId)&#123;// 判断条件1 判断传递值的变化 //获取文章数据 &#125; &#125; //方法2 &apos;$route&apos;(to, from) &#123; if (to.path == &quot;/page&quot;) &#123; /// 判断条件2 监听路由名 监听你从什么路由跳转过来的 this.message = this.$route.query.msg &#125; &#125; &#125; 异步函数中使用this无法指向vue实例对象问题描述 ： 在定时器或者其他异步函数中使用传统的func导致this指向不到vue实例，主要原因是因为this指向的问题 解决方案 ：用箭头函数或者指定变量赋值为this（其他一些不能用箭头函数的地方自己也要注意） 定时器在组件销毁后还在执行问题描述 ：一些耗费性能的计时器或者动画在组件销毁之后还是执行的，导致性能变低。 解决方案 ：在销毁组件的生命周期中销毁定时器或者一些动画的js 12345//组件销毁前执行的钩子函数，跟其他生命周期钩子函数的用法相同。beforeDestroy()&#123; //我通常是把setInterval()定时器赋值给this实例，然后就可以像下面这么停止。 clearInterval(this.intervalId);&#125; 动态添加的dom没有样式问题描述：作为常识我们知道style中的样式都会追加scoped，这样针对模板dom中的样式就可以生效，但其生效后的最终样式并不是我们写的样式名，而是编码后的，所以我们在js中拼接上的dom结构样式并不会生效。 解决思路： 当添加的部分样式不会太多，而且是动态加载的，可以将其设置为非scopred的 将添加dom部分用的样式放到非scoped样式标签中 将添加的部分，如果有必要，可以另外写一个页面拆分的vue组件 拓展 ： 项目中引入的其他ui框架的样式，如果你想覆盖修改，也是需要不加scoped的，如果你想整个项目覆盖，就可以在src/styles下定义customer-element.scss 这样的来重写覆盖样式。 vue中直接修改数据，页面视图不更新问题描述 ：在常规理解中，视图与数据是双向绑定的，但是有时候修改data的数组或者对象值，视图不会更新 。 1234567891011121314151617data() &#123; // data数据 return &#123; arr: [1,2,3], obj:&#123; a: 1, b: 2 &#125; &#125;; &#125;, // 数据更新 数组视图不更新 this.arr[0] = &apos;OBKoro1&apos;; this.arr.length = 1; console.log(arr);// [&apos;OBKoro1&apos;]; // 数据更新 对象视图不更新 this.obj.c = &apos;OBKoro1&apos;; delete this.obj.a; console.log(obj); // &#123;b:2,c:&apos;OBKoro1&apos;&#125; 解决方案 ：由于js的限制，Vue 不能检测以上数组的变动，以及对象的添加/删除，很多人会因为像上面这样操作，出现视图没有更新的问题。 this.$set(你要改变的数组/对象，你要改变的位置/key，你要改成什么value) 1234567 this.$set(this.arr, 0, &quot;OBKoro1&quot;); // 改变数组 this.$set(this.obj, &quot;c&quot;, &quot;OBKoro1&quot;); // 改变对象 ``` 2. 数组原生方法触发视图更新: splice()、 push()、pop()、shift()、unshift()、sort()、reverse() 推荐使用splice方法会比较好自定义,因为slice可以在数组的任何位置进行删除/添加操作3. 替换数组 比方说:你想遍历这个数组/对象，对每个元素进行处理，然后触发视图更新 // 文档中的栗子: filter遍历数组，返回一个新数组，用新数组替换旧数组 example1.items = example1.items.filter(function (item) { return item.message.match(/Foo/) }) 12345678910111213141516171819202122232425262728293031323334### ES6 import 引用问题在 ES6 中，模块系统的导入与导出采用的是引用导出与导入（非简单数据类型），也就是说，如果在一个模块中定义了一个对象并导出，在其他模块中导入使用时，导入的其实是一个变量引用（指针），如果修改了对象中的属性，会影响到其他模块的使用。通常情况下，系统体量不大时，我们可以使用 JSON.parse(JSON.stringify(str)) 简单粗暴地来生成一个全新的深度拷贝的 数据对象。不过当组件较多、数据对象复用程度较高时，很明显会产生性能问题，这时我们可以考虑使用 Immutable.js。鉴于这个原因，进行复杂数据类型的导出时，需要注意多个组件导入同一个数据对象时修改数据后可能产生的问题。此外，模块定义变量或函数时即便使用 let 而不是 const，在导入使用时都会变成只读，不能重新赋值，效果等同于用 const 声明。### 动态懒加载组件背景：在webpack的新特性中支持组件的懒加载，也就是说我们可以在加载到该路由的时候再把这部分脚本进行加载，同时这个在项目进行打包的时候，对应的文件也会被单独打包，对于首屏优化以及其他页面的资源加载优化都是非常好的。这也要求我们在每个页面组件使用组件的时候尽量按需引入，提升体验。问题场景：那么我们需要解决的问题是：1. webpack是静态解析路径的，直接传入变量并不可行2. 每次都写一串加载组件的代码很不方便，是否可以支持写成一个加载组件的方法3. 是否支持区分生产和开发环境，因为开发环境使用懒加载会导致热更新，导致更新变慢，所以开发环境使用全量默认加载，生产环境使用懒加载解决方案如下 ：1. webpack的路径使用变量拼接，必须预先给出一个相对路径，然后把具体的组件路径在传入2. 用一个箭头函数，将需要传入的组件名或者相对路径传入3. 用process.env.NODE_ENV确定使用哪种加载方式代码如下：在原来的router/index.js中，定义一个加载组件的_import方法。 // router/index.js const _import = require(&apos;./_import_&apos; + process.env.NODE_ENV) //使用时 { path: &apos;/&apos;, name: &apos;HelloWorld&apos;, component: _import(&apos;HelloWorld&apos;) }, // router/_import_development.js module.exports = file =&gt; require(&apos;@/views/&apos; + file + &apos;.vue&apos;).default // vue-loader at least v13.0.0+ // router/_import_production.js 如果你加载的vue不是这个路径 请自定义哦 module.exports = file =&gt; () =&gt; import(&apos;@/views/&apos; + file + &apos;.vue&apos;) 123456### ref使用虽然vue不建议直接操作dom，但是在复杂的场景中，我们需要进行dom的操作，这时候就可以借助ref实现。比如下面我们举一个简单的例子，通过ref获取dom节点，拿到其内容。解决方案 ： &lt;div @click=&quot;handleClick&quot; ref=&quot;hello&quot;&gt;hello world &lt;/div&gt; handleClick(){ console.log(this.$refs.hello) } 12拓展案例 ：实现计数器加和 场景 ：假设我们有两个计数器组件的实例，现在需要用ref的方案得到两个计数器的加和。 &lt;counter ref=&quot;one&quot; @change=&quot;handleChange&quot;&gt;&lt;/counter&gt; &lt;counter ref=&quot;two&quot; @change=&quot;handleChange&quot;&gt;&lt;/counter&gt; &lt;span&gt;{{total}}&lt;/span&gt; Vue.component(&quot;counter&quot;,{ template:&quot;&lt;div @click=&apos;change&apos;&gt;{{number}}&lt;/div&gt;&quot;, data(){ return { number:0} }, methods:{ change(){ this.number++; this.$emit(&quot;change&quot;) } } }) //app父组件方法 handleChange(){ this.total=this.$refs.one.number+this.$refs.two.number }, ` 拓展认知 ： this.$refs.name中如果是原生标签，拿到的是原生标签的节点，如果是组件，拿到的是组件的引用。 参考文档vue项目实践中的一些问题]]></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CKeditor使用心得]]></title>
    <url>%2F2018%2F04%2F26%2F2018-04-26-CKeditor%E4%B8%AA%E4%BA%BA%E4%BD%BF%E7%94%A8%E5%BF%83%E5%BE%97%2F</url>
    <content type="text"><![CDATA[前言作为一名大四的毕业在即的学生，毕业设计是逃不掉的一个事情。 在我的毕业设计里，运用到了一个富文本编辑器CKeditor，并且踩了很多的坑。 下面我就详细的介绍一下我踩过的坑，以及解决的办法。 正文 CKeditor是个啥东西CKeditor是当前比较流行的在线网页富文本编辑器，能够在线编辑一些文章并且可以添加很多的符号或者对文章进行相应的操作。 我用的是版本是Ckeditor4的版本 里面简单展示了CKeditor的用法以及主要效果。 CKeditor怎么操作下载压缩包首先我是用的JS进行操作，首先要下载下来主要的压缩包。 Basic Package是基础压缩包，代表着最基本的功能模块，主要是对文字进行操作的模块，以及图片的处理。 Standard Package是标准压缩包，代表更复杂的功能模块。 Full Package是除了自定义的压缩包之外，拥有最复杂功能模块的压缩包。 最下方的Online Builder在线自定义功能模块的压缩包下载方式。这个里面涉及到我踩的一个坑，之后在文章里会说到。 引入文件将下载完成的压缩包解压缩放在网站的资源目录下，对里面的js文件进行引入，建议是在页面头部进行引入，以便于在页面文档加载完成之前加载文件js。 1&lt;script src="/static/bower_components/ckeditor/ckeditor.js"&gt;&lt;/script&gt; HTML渲染引入js文件之后，需要在文档中，在你需要该文本编辑器的地方放入相应的代码，以便于js文件对HTML进行渲染。 123&lt;div&gt; &lt;textarea id="ckeditor" rows="10" cols="80"&gt;&lt;/textarea&gt; &lt;/div&gt; 这段代码就是在文档中需要添加的代码，CKeditor是对于textarea标签进行渲染的，所以必须是这个标签，标签的id是需要的以便于之后的js在页面中的渲染。 JS初始化当你完成上述两个操作之后，需要在js中对CKeditor进行初始化，从而让CKeditor可以在页面进行渲染。 1CKEDITOR.replace('ckeditor'); 这样初始化之后就会在界面中渲染出编辑器的界面，当然这是最初级的初始化，没有涉及到更加复杂的配置。 下面就开始讲我在毕业设计里踩过的坑。 CKeditor图片处理问题具体问题是啥我毕业设计里面用CKeditor的一个原因就是需要在线编辑图片，对图片进行上传，并且可以在此放到本地浏览。 在CKeditor编辑器里面默认集成了图片功能。 上图就是基础CKeditor编辑器里面自带的图片功能(其中上传模块是我后期配置的，文章下方会讲解怎么配置) 可以看出图片功能主要是可以设置大小以及对齐方式还有间距的设置，同时可以设置替换的文字以及图片标题。 首先，我在最开始使用CKeditor图片功能的时候是懵逼的，我一开始以为就只能加载在线的图片，需要图片的在线链接记性图片的获取。 后来在网上查了一下才发现是需要进行配置的，首先要找到你刚才安装CKeditor的文件目录中的plugins/image/dialogs/image.js 在这个文件中找到12id: "Upload",hidden: !0, 将 !0 改为 false，就会在图片页面中显示上传功能。 然后我就发现，选择图片之后选择上传到服务器是没有任何反应的，并且有可能会显示内部服务器错误。 这个时候需要一个好基友上线 CKFinder，这是和CKeditor在上传文件的时候成对使用插件。 该插件主要是和CKeditor一起出现使用，主要是用来上传文件包括图片。 下载CKfinder压缩包在CKfinder官网下载 下载压缩包并且解压缩到你CKeditor的同级目录下，然后就是最关键的一步。 JS初始化重新配置在你下在并且安装解压CKfinder之后，需要对你的JS进行配置，以便于让CKeditor与CKfinder协调工作，具体代码如下 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849CKEDITOR.replace('newquestion', &#123; extraPlugins: 'image,uploadimage', toolbar: [&#123; name: 'clipboard', items: ['Undo', 'Redo'] &#125;, &#123; name: 'styles', items: ['Styles', 'Format'] &#125;, &#123; name: 'basicstyles', items: ['Bold', 'Italic', 'Strike', '-', 'RemoveFormat'] &#125;, &#123; name: 'paragraph', items: ['NumberedList', 'BulletedList', '-', 'Outdent', 'Indent', '-', 'Blockquote'] &#125;, &#123; name: 'links', items: ['Link', 'Unlink'] &#125;, &#123; name: 'insert', items: ['Image', 'Table'] &#125;, &#123; name: 'tools', items: ['Maximize'] &#125;, &#123; name: 'editing', items: ['Scayt'] &#125; ], // Configure your file manager integration. This example uses CKFinder 3 for PHP. filebrowserBrowseUrl: '/static/bower_components/ckfinder/ckfinder.html', filebrowserImageBrowseUrl: '/static/bower_components/ckfinder/ckfinder.html?type=Images', filebrowserUploadUrl: '/static/bower_components/ckfinder/core/connector/php/connector.php?command=QuickUpload&amp;type=Files', filebrowserImageUploadUrl: '/static/bower_components/ckfinder/core/connector/php/connector.php?command=QuickUpload&amp;type=Images', // Upload dropped or pasted images to the CKFinder connector (note that the response type is set to JSON). uploadUrl: '/static/bower_components/ckfinder/core/connector/php/connector.php?command=QuickUpload&amp;type=Files&amp;responseType=json', // Reduce the list of block elements listed in the Format drop-down to the most commonly used. format_tags: 'p;h1;h2;h3;pre', // Simplify the Image and Link dialog windows. The "Advanced" tab is not needed in most cases. removeDialogTabs: 'image:advanced;link:advanced',&#125;); 现在配置之后就能够将图片上传到本地服务器的文件夹中，同时默认的上传目录是在网站根目录的ckfinder目录下。 图片放大缩小操作在之前提到过在线自定义CKeditor压缩包，现在就是自定义压缩包其作用的时候 首先要先看CKeditor官方文档关于图片操作插件的说明 这个界面说明了图片插件怎么用，该图片插件是没有集成在CKeditor文件之中的，所以要用户手动添加插件。 所以这个时候要回到最初的下载界面，选择Online Builder模式下载压缩包，进入下图所示的界面。 可以选择Standard模式，然后在下图的界面左侧框中找到 #Enhanced Image#，然后点击中间的左箭头按钮，将插件放到自定义的压缩包内。 然后选择下载，最后将压缩包解压覆盖到最初的CKeditor目录，当然要讲上述的配置重新来一次。OvO。 现在就可以了，你可以进行上传图片并且可以对图片进行放大缩小的操作。 CKeditor编辑器内容获取这个是最简单的，就是一段代码的事。 1var content = CKEDITOR.instances.ckeditor1.getData(); ckeditor1是你textarea标签的name属性。 CKeditor编辑器内容设置这个意思是将获取的CKeditor编辑器内容重新渲染在CKeditor编辑器中，当然也是一段代码的事。 1CKEDITOR.instances.ckeditor1.setData('你的内容'); 同样ckeditor1是你要放内容的textarea标签的name属性。 结语目前，我在毕业设计中用到的基本就是这些功能，当然CKeditor里面还有更多的功能以及需要配置的方法。 我也没有时间去研究了，到此就先告一段落吧。]]></content>
      <categories>
        <category>Plugins</category>
      </categories>
      <tags>
        <tag>插件介绍</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[构建离线web应用]]></title>
    <url>%2F2018%2F04%2F24%2F2018-04-24-%E6%9E%84%E5%BB%BA%E7%A6%BB%E7%BA%BFweb%E5%BA%94%E7%94%A8%2F</url>
    <content type="text"><![CDATA[关于本文转自公众号前端早读课： 原文地址 译文地址 译者：墨白 前言我喜欢移动app，而且也是那些坚持使用Web技术构建移动应用程序的人之一。 经过技术的不断迭代（可能还有一些其它的东西），移动体验设计愈来愈平易近人，给予用户更好的体验。 而今天，我们就要介绍一个新技术–渐进式 web 应用程序。在理解这个概念并自己尝试了一下之后，我觉得没有必要再做 hybrid 应用了。 正文 我们准备做这样的一个demo： Progressive Web Apps渐进式 Web 应用是典型的旨在提高用户离线体验的 Web 应用。它解决了这样的问题：怎么才能不显示类似下面的离线错误？ 事实上，PWA 不仅解决了离线错误，还在恢复连接的时候将用户与内容连接起来。移动设备是渐进式 web 应用的主要使用场景。让我来告诉你为什么？ 桌面浏览器 用户打开电脑（在家、学校或者办公室） 检查是否连上网络，没有则手动连接 打开 web 应用 移动端浏览器 拿出手机 默认手机已经连接上网络 直接打开 app 如上，用户对待两种场景的处理方式是不一样的。移动端用户不一定有很好的网络连接，有的甚至没有。在这样的场景下，开发商需要做的就是保持用户对产品的好感，在其网络恢复时与其互动。如果信号很差，开发商需要通过一些手段保持用户的耐心，不至于在请求过程中用户直接关闭 web 应用。 当我们开始构建 PWA 应用时，你就能理解上面的场景了。 Service WorkersPWA 背后的原理是 service workers。如果想让用户在离线场景下依然保持打开 web 页面，你需要在用户打开 web 应用并且有网络连接时做一些“后台任务”，这个“后台任务”会搜集 web 页面最近一次运行需要的一些资源，以备离线时使用。 这就好像每年秋收储备粮食，以备冬天不时之需一样，不断循环。 PWA 中的 service worker，可以类比成春天的播种的农民。下面是 MDN 对 service workers 的描述： Service worker 是一个注册在指定源和路径下的事件驱动 worker。它采用 JavaScript 控制关联的页面或者网站，拦截并修改访问和资源请求，细粒度地缓存资源。你可以完全控制应用在特定情形（最常见的情形是网络不可用）下的表现。 简而言之，service worker 就是一些在后台运行逻辑的 worker。它没有权限操作 DOM，但是可以调用其它的 API （例如 IndexDB 以及 Fetch API）。 开始之前请牢记： service workers 只能在 HTTPS 协议下生效（或者 Localhost）。 service workers 被设计成异步的，不能使用 XHR （但你可以使用 Fetch）或者 LocalStorage。 service workers 的作用范围是针对相对路径的。因此，demo/sw.js 只能相对于 demo 起作用，demo/first/sw.js 相对于 first。 Mobile 还是 PWA如果你能利用 service workers 存储离线使用所需的文件，那你就没有必要开发移动 app 了。如果你的 web 应用对移动用户进行了优化，并且几乎不需要调用移动端的硬件功能，那么你应该尝试一下 PWA。 我花了一些时间看飞行模式下一些移动 app 的表现。我将它们分成三类： 离线情况下不做任何操作例子： Coinbase Coinbase 就是一直停留在 loading 的这个页面。它甚至让我怀疑这样的 app 为啥要存在，因为这个页面简直跟 web 展示一模一样。Coinbase 不是财经类 app，无需实时展示信息，因此，PWA 可能只适用应用于其 App Shell。 App Shell 是指不包含动态内容的一部分应用程序。例如导航菜单、侧边栏、背景、logo 等等。 离线情况下展示警告信息（未连接网络等等），展示 App Shell，但其它都不可用例子：Uber Uber 给用户展示了一些信息（通过 App Shell 以及地图），并且告知用户不能操作是由于他网络中断了。Uber是一个很高频的 app，这样的交互展示对于他们的应用场景很有意义。 离线情况下展示缓存的数据例子： Medium Medium在离线状态下展示缓存的数据，一些离线展示在这个分类里面的 app（例如，Instagram）还会提示用户离线了，所以，就不要对这个分类里面的 app 期望再搞了。 优化我的想法是，如果 PWA（或者 service workers）技术成熟并且被大规模应用的话，为什么不节省掉： 前往应用商店 下载并不常用的 app 呢？ 当我们接下来谈到 Web Manifest 时，你就意识到只要给你的 web 应用新增一个桌面 icon，web 应用就可以通过点击这个 icon 实现启动了。 一些公司已经在 PWA 方面做的比较好了，你可以在这个网址上面找到这些公司：pwa.rocks 开发准备我们已经介绍了足够多的理论知识了。这是一个手把手的教程，来吧，让我们动起手来。首先，按照下面的结构来创建一个新的项目： 1234567|--pwa-demo|----css|----fonts|----images|----js|----index.html|----service-worker.js 下载 Materialize 这个 UI 库，用里面 CSS、Fonts、js 文件分别替换项目里面的文件夹。 打开 index.html 文件，引入一些资源： 123456789101112131415161718192021222324252627282930313233343536373839404142&lt;!-- ./index.html --&gt;&lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;!--Import Google Icon Font--&gt; &lt;link href="https://fonts.googleapis.com/icon?family=Material+Icons" rel="stylesheet"&gt; &lt;!--Import materialize.css--&gt; &lt;link type="text/css" rel="stylesheet" href="css/materialize.min.css" media="screen,projection"/&gt; &lt;link type="text/css" rel="stylesheet" href="css/app.css"&gt; &lt;!--Let browser know website is optimized for mobile--&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"/&gt; &lt;/head&gt; &lt;body&gt; Body coming soon &lt;!-- Scripts --&gt; &lt;script type="text/javascript" src="js/jquery-2.1.1.min.js"&gt;&lt;/script&gt; &lt;script type="text/javascript" src="js/materialize.min.js"&gt;&lt;/script&gt; &lt;script type="text/javascript" src="js/app.js"&gt;&lt;/script&gt; &lt;/body&gt; &lt;/html&gt;``` 我们已经引入了下载好的文件，还需要自己在相应的目录创建一下 `app.css` 以及 `app.js` 这两个文件。## 注册 Service Worker越早在浏览器注册，Service Worker 就能越早的开始工作。最佳的做法是在应用的入口。在这个项目中，我们可以在 `app.js` 注册一个新的 worker：```js(function()&#123; if ('serviceWorker' in navigator) &#123; navigator.serviceWorker .register('/service-worker.js') .then(function() &#123; console.log('Service Worker Registered'); &#125;); &#125; &#125;)() 在做其他操作之前，我们首先需要检测一下浏览器对于 Service Worker 的兼容性。如果支持，那我们就可以利用 register 这个方法来注册这个 worker，这个方法告知了 service worker 文件的路径。注册函数返回一个 promise ，你可以在这个 promise 里面判断注册是否成功。 Service Worker 周期在开始构建 PWA 之前，你需要理解 Service Worker 的生命周期： Install这一阶段主要是让 worker 在浏览器给定的作用域挂载。由于这是生命周期的第一步，最好在这一步缓存各种资源： 12345678910111213141516171819// ./service-worker.jsvar cacheName = 'PWADemo-v1';var filesToCache = [ '/index.html', '/css/app.css', '/js/app.js', /* ...and other assets (jQuery, Materialize, fonts, etc) */];self.addEventListener('install', function(e) &#123; console.log('[ServiceWorker] Install'); e.waitUntil( caches.open(cacheName).then(function(cache) &#123; console.log('[ServiceWorker] Caching app shell'); return cache.addAll(filesToCache); &#125;) );&#125;); caches.open 和 cache.addAll 都是异步操作.service worker 在这些操作完成之前可能会中断,e.waitUntil用来等待 promise 的状态变成 resolved 或者 rejected。 当缓存开关被打开时，我们尝试利用 addAll 来新增缓存。 请记住，只要有一个文件缓存失败，service worker 就无法被正确挂载。 Activate当 worker 挂载完成，其效果并不会立即展示出来，除非前一个 service worker 销毁并且该 web 应用被重新访问。假设我们挂载了另一个不同 cacheName 的 service worker: 1234567891011// ./service-worker.jsvar cacheName = &apos;PWADemo-v2&apos;;var filesToCache = [ //...];self.addEventListener(&apos;install&apos;, function(e) &#123; console.log(&apos;[ServiceWorker] Install&apos;); //...&#125;); 当这个新的 service worker 创建之后，新的缓存 PWADemo-v2 也被创建，这时候 PWADemo-v1 仍然存在。当触发 Activate 时，我们可以删除 PWADemo-v1，使其“让位”于 PWADemo-v2： 123456789101112131415// ./service-worker.jsself.addEventListener('activate', function(e) &#123; console.log('[ServiceWorker] Activate'); e.waitUntil( caches.keys().then(function(keyList) &#123; return Promise.all(keyList.map(function(key) &#123; if (key !== cacheName) &#123; console.log('[ServiceWorker] Removing old cache', key); return caches.delete(key); &#125; &#125;)); &#125;) );&#125;); 我们检查所有的 cache 名称，如果发现不是正在使用的 cache，那么将其直接删除。 FetchFetch 不是一个必需的生命周期，但它提供了拦截请求资源的方法。当发送请求时，首先会触发这样的事件： 12345678910// ./service-worker.jsself.addEventListener('fetch', function(e) &#123; console.log('[ServiceWorker] Fetch', e.request.url); e.respondWith( caches.match(e.request).then(function(response) &#123; return response || fetch(e.request); &#125;) );&#125;); 如果资源已经被缓存了，我们返回浏览器缓存的版本。如果没有，那么我们调用 fetch api 去发送 HTTP 请求该资源。 Debuggering Service Workers由于 service workers 的工作方式，特别是进行缓存时，不是很容易进行 debugger 调试。幸运的是，chrome 的 dev tools 提供了助力。跟着下面的步骤，调试我们刚注册的 service worker： 打开 chrome dev tools 点击 Application 这一选项，打开 service worker 分区： 你可以查看到 status 是绿色的，这就表明你的 service worker 成功了： 你可以打开 “Update on reload” 去强制更新 service worker，不用关闭所有已存在的 session： 右击 “Cache Storage”，然后点击刷新去查看缓存。根据名称点击你所设置的cache，然后你就会看到缓存里面的各个项： 接下来你已经了解了必备的知识点，PWA 的概念对你来说已经不陌生了。接下来，我们将要讨论 PWA 的缓存策略。我们将了解如何使用 IndexDB 来保存数据而不是 localStorage。]]></content>
      <categories>
        <category>PWA</category>
      </categories>
      <tags>
        <tag>网络技术</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[浏览器缓存机制]]></title>
    <url>%2F2018%2F04%2F20%2F2018-04-20-%E6%B5%8F%E8%A7%88%E5%99%A8%E7%BC%93%E5%AD%98%E6%9C%BA%E5%88%B6%2F</url>
    <content type="text"><![CDATA[前言如果你还在找工作面试，可以适当的了解下。今日早读文章由@葉河英投稿分享。 @叶河英，腾讯前端工程师，主要研发系统和电商平台项目 正文 概述浏览器的缓存机制也就是我们说的HTTP缓存机制，其机制是根据 HTTP报文 的缓存标识进行的，所以在分析浏览器缓存机制之前，我们先使用图文简单介绍一下HTTP报文，HTTP报文分为两种： HTTP请求(Request)报文，报文格式为：请求行 – HTTP头(通用信息头，请求头，实体头) – 请求报文主体(只有POST才有报文主体)，如下图 HTTP响应(Response)报文，报文格式为：状态行 – HTTP头(通用信息头，响应头，实体头) – 响应报文主体，如下图 注：通用信息头指的是请求和响应报文都支持的头域，分别为Cache-Control、Connection、Date、Pragma、Transfer-Encoding、Upgrade、Via；实体头则是实体信息的实体头域，分别为Allow、Content-Base、Content-Encoding、Content-Language、Content-Length、Content-Location、Content-MD5、Content-Range、Content-Type、Etag、Expires、Last-Modified、extension-header。这里只是为了方便理解，将通用信息头，响应头/请求头，实体头都归为了HTTP头。 以上的概念在这里我们不做多讲解，只简单介绍，有兴趣的童鞋可以自行研究。 缓存过程分析浏览器与服务器通信的方式为应答模式，即是：浏览器发起HTTP请求 – 服务器响应该请求。那么浏览器第一次向服务器发起该请求后拿到请求结果，会根据响应报文中HTTP头的缓存标识，决定是否缓存结果，是则将请求结果和缓存标识存入浏览器缓存中，简单的过程如下图： 由上图我们可以知道： 浏览器每次发起请求，都会先在浏览器缓存中查找该请求的结果以及缓存标识 浏览器每次拿到返回的请求结果都会将该结果和缓存标识存入浏览器缓存中 以上两点结论就是浏览器缓存机制的关键，他确保了每个请求的缓存存入与读取，只要我们再理解浏览器缓存的使用规则，那么所有的问题就迎刃而解了，本文也将围绕着这点进行详细分析。为了方便大家理解，这里我们根据是否需要向服务器重新发起HTTP请求将缓存过程分为两个部分，分别是强制缓存和协商缓存。 强制缓存强制缓存就是向浏览器缓存查找该请求结果，并根据该结果的缓存规则来决定是否使用该缓存结果的过程，强制缓存的情况主要有三种(暂不分析协商缓存过程)，如下： 不存在该缓存结果和缓存标识，强制缓存失效，则直接向服务器发起请求（跟第一次发起请求一致），如下图： 存在该缓存结果和缓存标识，但该结果已失效，强制缓存失效，则使用协商缓存(暂不分析)，如下图 存在该缓存结果和缓存标识，且该结果尚未失效，强制缓存生效，直接返回该结果，如下图 那么强制缓存的缓存规则是什么？当浏览器向服务器发起请求时，服务器会将缓存规则放入HTTP响应报文的HTTP头中和请求结果一起返回给浏览器，控制强制缓存的字段分别是Expires和Cache-Control，其中Cache-Control优先级比Expires高。 ExpiresExpires是HTTP/1.0控制网页缓存的字段，其值为服务器返回该请求结果缓存的到期时间，即再次发起该请求时，如果客户端的时间小于Expires的值时，直接使用缓存结果。 Expires是HTTP/1.0的字段，但是现在浏览器默认使用的是HTTP/1.1，那么在HTTP/1.1中网页缓存还是否由Expires控制？ 到了HTTP/1.1，Expire已经被Cache-Control替代，原因在于Expires控制缓存的原理是使用客户端的时间与服务端返回的时间做对比，那么如果客户端与服务端的时间因为某些原因（例如时区不同；客户端和服务端有一方的时间不准确）发生误差，那么强制缓存则会直接失效，这样的话强制缓存的存在则毫无意义，那么Cache-Control又是如何控制的呢？ Cache-Control在HTTP/1.1中，Cache-Control是最重要的规则，主要用于控制网页缓存，主要取值为： public：所有内容都将被缓存（客户端和代理服务器都可缓存） private：所有内容只有客户端可以缓存，Cache-Control的默认取值 no-cache：客户端缓存内容，但是是否使用缓存则需要经过协商缓存来验证决定 no-store：所有内容都不会被缓存，即不使用强制缓存，也不使用协商缓存 max-age=xxx (xxx is numeric)：缓存内容将在xxx秒后失效 接下来，我们直接看一个例子，如下： 由上面的例子我们可以知道： HTTP响应报文中expires的时间值，是一个绝对值 HTTP响应报文中Cache-Control为max-age=600，是相对值 由于Cache-Control的优先级比expires，那么直接根据Cache-Control的值进行缓存，意思就是说在600秒内再次发起该请求，则会直接使用缓存结果，强制缓存生效。 注：在无法确定客户端的时间是否与服务端的时间同步的情况下，Cache-Control相比于expires是更好的选择，所以同时存在时，只有Cache-Control生效。 了解强制缓存的过程后，我们拓展性的思考一下：浏览器的缓存存放在哪里，如何在浏览器中判断强制缓存是否生效？ 这里我们以博客的请求为例，状态码为灰色的请求则代表使用了强制缓存，请求对应的Size值则代表该缓存存放的位置，分别为from memory cache 和 from disk cache。 from memory cache代表使用内存中的缓存，from disk cache则代表使用的是硬盘中的缓存，浏览器读取缓存的顺序为memory –&gt; disk。 虽然我已经直接把结论说出来了，但是相信有不少人对此不能理解，那么接下来我们一起详细分析一下缓存读取问题，这里仍让以我的博客为例进行分析： 访问https://heyingye.github.io/ –&gt; 200 –&gt; 关闭博客的标签页 –&gt; 重新打开https://heyingye.github.io/ –&gt; 200(from disk cache) –&gt; 刷新 –&gt; 200(from memory cache) 过程如下： 访问https://heyingye.github.io/ 关闭博客的标签页 重新打开https://heyingye.github.io/ 刷新 看到这里可能有人小伙伴问了，最后一个步骤刷新的时候，不是同时存在着from disk cache和from memory cache吗？ 对于这个问题，我们需要了解内存缓存(from memory cache)和硬盘缓存(from disk cache)，如下: 内存缓存(from memory cache)：内存缓存具有两个特点，分别是快速读取和时效性： 快速读取：内存缓存会将编译解析后的文件，直接存入该进程的内存中，占据该进程一定的内存资源，以方便下次运行使用时的快速读取。 时效性：一旦该进程关闭，则该进程的内存则会清空。 硬盘缓存(from disk cache)：硬盘缓存则是直接将缓存写入硬盘文件中，读取缓存需要对该缓存存放的硬盘文件进行I/O操作，然后重新解析该缓存内容，读取复杂，速度比内存缓存慢。 在浏览器中，浏览器会在js和图片等文件解析执行后直接存入内存缓存中，那么当刷新页面时只需直接从内存缓存中读取(from memory cache)；而css文件则会存入硬盘文件中，所以每次渲染页面都需要从硬盘读取缓存(from disk cache)。 协商缓存协商缓存就是强制缓存失效后，浏览器携带缓存标识向服务器发起请求，由服务器根据缓存标识决定是否使用缓存的过程，主要有以下两种情况： 协商缓存生效，返回304，如下 协商缓存失效，返回200和请求结果结果，如下 同样，协商缓存的标识也是在响应报文的HTTP头中和请求结果一起返回给浏览器的，控制协商缓存的字段分别有：Last-Modified / If-Modified-Since和Etag / If-None-Match，其中Etag / If-None-Match的优先级比Last-Modified / If-Modified-Since高。 Last-Modified / If-Modified-SinceLast-Modified是服务器响应请求时，返回该资源文件在服务器最后被修改的时间，如下。 If-Modified-Since则是客户端再次发起该请求时，携带上次请求返回的Last-Modified值，通过此字段值告诉服务器该资源上次请求返回的最后被修改时间。服务器收到该请求，发现请求头含有If-Modified-Since字段，则会根据If-Modified-Since的字段值与该资源在服务器的最后被修改时间做对比，若服务器的资源最后被修改时间大于If-Modified-Since的字段值，则重新返回资源，状态码为200；否则则返回304，代表资源无更新，可继续使用缓存文件，如下。 Etag / If-None-MatchEtag是服务器响应请求时，返回当前资源文件的一个唯一标识(由服务器生成)，如下。 If-None-Match是客户端再次发起该请求时，携带上次请求返回的唯一标识Etag值，通过此字段值告诉服务器该资源上次请求返回的唯一标识值。服务器收到该请求后，发现该请求头中含有If-None-Match，则会根据If-None-Match的字段值与该资源在服务器的Etag值做对比，一致则返回304，代表资源无更新，继续使用缓存文件；不一致则重新返回资源文件，状态码为200，如下。 注： Etag / If-None-Match优先级高于Last-Modified / If-Modified-Since，同时存在则只有Etag / If-None-Match生效。 总结强制缓存优先于协商缓存进行，若强制缓存(Expires和Cache-Control)生效则直接使用缓存，若不生效则进行协商缓存(Last-Modified / If-Modified-Since和Etag / If-None-Match)，协商缓存由服务器决定是否使用缓存，若协商缓存失效，那么代表该请求的缓存失效，重新获取请求结果，再存入浏览器缓存中；生效则返回304，继续使用缓存，主要过程如下：]]></content>
      <categories>
        <category>Cache</category>
      </categories>
      <tags>
        <tag>网络技术</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[前端布局]]></title>
    <url>%2F2018%2F04%2F03%2F2018-04-03-%E5%89%8D%E7%AB%AF%E5%B8%83%E5%B1%80%E5%9F%BA%E7%A1%80%E6%A6%82%E8%BF%B0%2F</url>
    <content type="text"><![CDATA[前言在刚刚过去的第四届CSS大会上，不少人提到了布局的问题。那么这篇很适合重温一下。文章由@蔡剑涛分享，转自公众号：前端早读课。 @蔡剑涛,来自海致星图前端团队,专注前端项目架构设计、组件库开发、开发流程精进和团队技术体系建设 背景前端圈有个“梗”：在面试时，问个css的position属性能刷掉一半人，其中不乏工作四五年的同学。在公司一直有参与前端的基础面试，深感这个“梗”不是个玩笑。 然而，我觉得实际比例可能会更高，甚至很多面试官自己也未必真正掌握。因为大部分前端同学，可能不知道初始包含块的概念，或知道但对这个概念理解有误。 造成这种现象的原因主要有两方面，一方面是在介绍这个知识点时，网上有谬误的文章太多，国内外亦如此（MDN也名列其中），导致很多同学被误导（我一开始也是），而且这种错误被代代相传；另一方面可能是我们平时不太注重概念的定义、自身对待知识的态度还不够严谨、缺乏验证精神和系统总结的习惯。 一次偶然的机会，我发现了这种谬误，并找到了W3C组织对初始化包含块的官方定义，也为了让刚入前端圈的同学少走一些弯路，在此我想借本文分享给大家（详述请见5.5. 包含块章节），也系统分享一下，本人在前端布局基础方面积累的浅薄经验。（因为是系统概述，所以篇幅会比较长，希望各位读者有心理准备） 什么是前端布局基础？前端布局方案主要有三种： 传统布局方案（借助浮动、定位等手段） flex布局方案 grid布局方案 这些方案都能够解决布局问题，而且每个方案都有各自的理论基础，那么哪一个方案的基础理论可以称得上是前端布局基础？要回答这个问题，我们还得深入去了解这三种方案的特性。 传统布局方案，需要使用者熟练掌握元素的分类及布局特性、浮动原理和定位原理等众多基础知识，方能在解决各类前端布局问题时游刃有余，这不仅学习成本大，而且实现的复杂度也高，实现的CSS代码也不够精简、优雅。但由于其基础知识来源于CSS2，所以浏览器兼容性最好，对于用户是友好的。 flex布局方案，正是为了解决传统布局方案的种种不便，而提出的一种新型改进方案，它不再需要借助浮动和定位等布局手段，而是通过父元素（flex box）单方面配置相关的CSS属性来决定子元素的布局规则，且在大多情况下无需子元素（flex item）参与，就能完成子元素间的布局问题，不仅学习成本低（公司之前有几个后端工程师亦能快速上手），且大大简化了布局的实现复杂度，CSS代码也更加精炼。美中不足的是IE10才开始支持，且需要使用-ms-前缀（IE11无需）。 虽然现今的手机多使用的是现代浏览器，对flex支持度较好，然而并不是每一款手机都如此：笔者曾在一个移动端项目采用过flex布局方案，然而公司的测试同学在“华为荣耀5”的自带浏览器，检测到无法支持flex布局，我们能够跟测试的同学说，是这款华为手机的浏览器有问题吗？显然不能。于是故笔者在项目早期就及时放弃了flex布局方案，改用传统布局方案实现，避免了后面大规模的改动。 grid布局方案，是由微软提出，相对于传统布局方案和flex布局方案，它是一种二维布局方案，在IE10开始支持，但需要使用-ms-后缀（IE11+不再需要）。 总的来说，这三类方案都能基本解决日常的前端布局问题，且从易用性、灵活性和强大性来说，flex布局和grid布局更是未来的趋势。但是从当前各版本浏览器在用户市场上的使用情况和各方案的浏览器兼容性来看，传统布局方案对用户最友好，具有一定的不可替代性，所以我觉得，传统布局方案是最应该先掌握好的，尤其是对于在to B企业工作的前端同学来说。 所以本文将详细介绍的“前端布局基础”，指的是围绕着“传统布局方案”的众多CSS知识，其主要内容来源于CSS2规范。 为什么要学好前端布局基础？页面写多了的前端同学，我想应该都会有这样一个深刻的感受：在编写页面时，经常会遇到不同场景的布局问题，我们不仅需要针对特定的场景选定可实现的布局实现方案，而且需要考虑未来可能发生的变化。 而要做好这一点，就需要扎实的前端基础作为依托。 所以在我看来，学好前端布局基础，其目的是为了在面对不同场景的布局问题时，能够提出一种合理的布局方案：既能解决问题，又能最大程度地拥抱变化。 量化布局方案的合理性前面提到过的“解决问题”、“拥抱变化”，仅仅是合理布局方案的两大核心目标，如果想要让目标更好地落地，我们仍需要一些量化合理性的原则，来提升对目标的方向感，以让目标变得更加可执行。 说到量化“解决问题”这个目标，对于即写即呈现的前端代码来说，我们可以很直观地判断一种方案是否可行，所以不需要太多的量化手段，我们主要是要量化“拥抱变化”这个目标。 要想量化“拥抱变化”这个目标，我们首先得清楚“变化”有哪些。笔者根据过往的开发经验，将变化分为两大类：一是布局需求的变化，二是运行环境的变化。 而针这这两类变化，我提出如下量化原则： 一、对于布局需求的变化，可以做到： 方便快速定位需修改的位置 能够不花或用最少的修改成本应对变化 二、对于运行环境的变化，可以做到： 在不同浏览器均有正确或良好的显示 如果一个方案能够体现以上几点原则，我认为可以称得上是一个合理的方案。最后，我将布局实现方案的合理性归纳为：方案在满足正确性的前提下，其实现逻辑规范、实现职责分明且拥有良好的浏览器兼容性。 下面我们正式开始介绍与“传统布局方案”相关的布局基础知识。 正文布局基础要点### CSS标准盒模型(或W3C盒模型) 一个web页面是由众多html元素拼凑而成的，而每一个html元素，都被解析为一个矩形盒，而CSS盒模型就是这种矩形盒的解构模型。CSS盒模型，它由内到外、被四条边界Content edge、Padding edge、Border edge和Margin edge划分为四个区域：Content area、Padding area、Border area和Margin area，在形状上，Content area（又称content-box）是实心矩形，其余是空心环形（空心部分是Content area），如下图所示： 此外，每个区域都有其特定的作用：Content area，是当前元素用来容纳所有子孙元素；Padding area，是当前元素用来隔离自身和子孙元素；Border area是当前元素用来显示自身的轮廓；Margin area，是当前元素用来隔离自身和相邻元素。理解每个区域的作用和职责至关重要，有助于我们写出优雅、清晰的布局代码。 而每个区域的尺寸，又分别由特定的CSS属性来控制，如下图所示： 这些CSS尺寸属性（width、height、padding、border和margin），相当于一个个hook，我们可以通过设置这些“hook”来达到调整元素尺寸的目的。 box-sizing（CSS3属性）1. box-sizing的作用box-sizing，顾名思义，其作用与设置CSS box的尺寸大小有关，而CSS box又可细分为: content-box(即content area) padding-box(=content area + padding area) border-box(=content area + padding area + border area) margin-box(=content area + padding area + border area + margin area) 简单来说，box-sizing的作用就是告诉浏览器：CSS属性width和height是用于设置哪一种box的尺寸，在W3C标准中,box-sizing的值仅有content-box和border-box（firefox则额外支持padding-box）。所以， 当box-sizing的值为content-box（默认值）时，有： 1234width = content-width;height = content-height; 当box-sizing的值为border-box时，有： 1234width = content-width + padding-left + padding-right + border-left-width + border-right-width;height = content-height + padding-top + padding-bottom + border-top-height + border-bottom-height; 关于box-sizing的作用，还有另一种表述：告诉浏览器，是使用W3C盒模型，还是使用IE盒模型。 2. box-sizing的浏览器兼容性box-sizing是CSS3属性，在IE8+（包含IE8）开始支持，然而在IE8，box-sizing的值为border-box时，不能与min-width, max-width, min-height或max-height的一起使用，因为IE8对min-和max-的解析，仍是作用于content-box，不受box-sizing属性控制。 3. box-sizing的产生原因仅仅掌握box-sizing的基础使用，是无法真正理解box-sizing的作用，所以要想把box-sizing用好，我们还得从CSS盒模型的发展史来深入理解box-sizing的产生原因。 在CSS的发展历程中，有两个版本，一个是IE盒模型，另外一个是W3C盒模型。IE盒模型，在IE5-（包含IE5）和navigator4上均有使用；而W3C盒模型，在IE6+（包含IE6）标准模式开始得到支持。两种版本的盒模型，其实在模型结构上是一致的，只是with和height属性的计算规则不一样，其区别，等价于“box-sizing的两个属性值border-box和content-box的区别“，如下图所示： 在了解了CSS盒模型的发展历程，以及后来新增的box-sizing的开始支持时间，我们不难发现： IE5-采用IE盒模型 IE6、7的标准模式放弃了IE盒模型，转为使用W3C盒模型 IE8+借助box-sizing，又重新提供了对IE盒模型的支持 对于IE盒模型，我们看到了W3C组织先去后留的反复态度，我不禁提出以下两点疑惑： 问题一：为什么W3C组织在制定盒模型标准时，一开始会放弃IE盒模型，而重新建立以content-box为计算规则的W3C盒模型？W3C盒模型比IE盒模型好在哪里？ 问题二：为什么在CSS3中，又重新提供了对IE盒模型的支持（box-sizing设置为border-box），又是基于哪方面的考虑？ 关于第一个问题，本人并没有找到相关的官方说明，但我比较认可的一种说法是： 在日常生活中，我们在放东西时，会关心东西放到多大的盒子里面，这里的“多大”，往往指的是盒子的容量，而不是整个盒子的尺寸。而HTML元素也被看成是一个盒子、一个容器，相应地，我们也会更关注其内容区域的尺寸，也更希望对内容区域有更强的控制力。所以，从存储的角度来看，W3C盒模型更符合这种认知，借助width和height，我们可以通过声明的方式，直接设置conent-box的尺寸。而如果采用IE盒模型，我们只能先设置整个盒子的尺寸（border-box），最后由浏览器自动计算出content-box的尺寸，显得对content-box尺寸的控制力较弱。 关于第二个问题，我认为有以下几个原因： &emsp;&emsp; 1. 有助于复用基于IE盒模型开发的CSS代码； &emsp;&emsp; 2. IE盒模型的“遗老遗少”可以延续计算习惯； &emsp;&emsp; 3. 部分html元素，在解析时依然采用IE盒模型的计算规则（这样的元素有select、button），使用IE盒模型有助于保持一致性； &emsp;&emsp; 4. 从元素布局的角度来看，IE盒模型的width和height的语义更符合人类的直观认知（盒子的尺寸、轮廓应该以border为界）； &emsp;&emsp; 5. 在弹性布局和响应式布局场景，IE盒模型比W3C盒模型表现更佳（更容易实现、浏览器兼容性更好），如设置某个元素的宽度始终占当前行总宽度的固定百分比（小于100%），并且该元素拥有固定像素的padding； 举个例子：设置一个元素，其宽度分别为当前行的40%，且该元素的padding固定为10px。 IE盒模型的实现方案： 方案一： 使用一个div即可实现，直接设置width为40%，padding为10px； W3C盒模型的实现方案： 方案一：使用两个div模拟实现，外层div的width设置为40%，内层div的padding为10px,width为auto； 方案二：使用一个div即可实现，但是需要借用CSS3的calc函数，动态计算其内容区域的宽度，即width为calc(40% - 20px), padding为10px； 显然，IE盒模型的实现方案更加简洁，而且浏览器兼容性更好。 对上述两个问题的解答，其实也是对IE盒模型和W3C盒模型的一个比较。我们可以从比较中，明晰两种盒模型各自的优缺点。同时，经过大量的实践经验证明和充分讨论，IE盒模型总体上是优于W3C盒模型，这也是IE盒模型能够“王者归来”，被W3C组织重新启用的真正原因。 于是乎，为了重新在新规范中支持IE盒模型，也为了向后兼容W3C盒模型，W3C组织在CSS3中添加了box-sizing属性，用于切换这两种盒模型。 4. 对box-sizing的评价在我看来，在CSS3中添加box-sizing其实是一种比较trick的弥补方式。虽然这种设计能重新提供对IE盒模型的支持，但是在某种程度上，造成了CSS属性width和height具有二义性，使其职责变得不单一。然而这似乎又是最可取的修正方案了，因为在网上已经存在了大量基于W3C盒模型开发的网页，后续的修正方案不得不考虑向后兼容。我们只能在不合理设计的基础上，再次用不优雅的设计来解决新的问题。 如果能够穿越时空，回到W3C组织在讨论“如何设计标准盒模型”时，我认为更合适的设计方案是添加新的属性单独用于设置content-box的尺寸，而保留IE盒模型width和height原来的语义。这样就不会有后来的box-sizing属性。 我猜想W3C组织也想过这种方案，但是当时可能认为： &emsp;&emsp; 1. 直接设置元素border-box尺寸的意义不大，且border-box的尺寸设置也能够通过设置content-box的尺寸来实现；（其实同时两种支持content-box和border-box尺寸的设置也无妨，完全可以当做是语法糖） &emsp;&emsp; 2. 设置content-box尺寸又属于高频操作，若新增的属性命名为content-width或content-height则显得名称太长；（命名为cwidth和cheight也行） 基于这两点，最终提出了用width和height来设置content-box尺寸的解决方案，也就是如今我们看到的W3C盒模型。 纵观CSS盒模型的发展史和box-sizing的创建原因，感触比较深的就是：不合理的设计并不是总会被修正，因为既有实现的广泛应用，会使得其被继续遵循。而后续的新增设计，也是建立在先前不合理设计的基础上。这是否也验证了黑格尔的哲学名言：存在即合理？ 关于对box-sizing的评价和思考，可能显得有一些马后炮，一些猜想也可能只是笔者的凭空臆想，并非W3C组织原意。在这里只是为了分享我对重构的一些思考，也是为了与和我有同样疑惑的同学做个交流。 5. box-sizing的最佳实践在这里主要回答三个问题： 问题一：box-sizing的值，取content-box好，还是取border-box值好？ 如果最低需要兼容IE6、7，那么box-sizing不可使用，只能使用W3C盒模型； 如果最低只需兼容IE8，那么使用content-box在功能上完全没有问题，只是在一些弹性布局和响应式布局实现上，会稍微麻烦一点；而border-box虽然在这些方面表现更好，但是不能和IE8的min-width、min-height、max-width和max-height四个属性一同使用，使用的话就要稍微注意一下； 如果最低只需兼容IE9，那么本人觉得，全局配置取content-box更为合适，局部配置二者均可。原因如下： &emsp;&emsp; 1. CSS3提供了calc函数（IE9+），使得W3C盒模型有了强有力的助攻，在弹性布局和响应式布局的表现，与IE盒模型无异； &emsp;&emsp; 2. 默认优于配置原则：我个人认为，“默认优于配置”，特别是在reset.css这种架构级、平台级的配置文件，要尽量避免对未来可能引入的模块有侵入性。譬如，我们在一个项目中时常需要引入第三方组件，如果这个组件没有强声明box-sizing,那么其默认使用的就是W3C标准盒模型，如果在全局的reset.css中设置box-sizing的值为border-box以选用IE盒模型，那么就会影响到这一类默认基于W3C盒模型的第三方组件的样式。这里也给我们提了一个醒，在封装组件时，记得强声明box-sizing，哪怕你使用默认的content-box。 总之，大部分场景二者可以互换，只是使用理念不一样。小部分场景border-box更具优势，但随着calc函数的支持，这种优势已经不再，相反content-box是默认值的优势愈加明显。 我个人建议是：全局使用默认W3C盒模型（你的CSS代码最低能够兼容IE6/7，在IE8也可以和min-和max-一起使用），局部场景二者均可（仅把IE盒模型当作是一种布局技巧来使用）。你喜欢全局使用IE盒模型也是可以的，只要确认项目只需要兼容到IE8，即便有可能影响到引入的第三方组件，也是有办法处理的。 问题二：如果想要全局使用IE盒模型，那么在reset.css中，该怎样设置box-sizing？ 这里提供一个参考： 123456789101112html &#123; -webkit-box-sizing: border-box; -moz-box-sizing: border-box; box-sizing: border-box;&#125;*, *:before, *:after &#123; -webkit-box-sizing: inherit; -moz-box-sizing: inherit; box-sizing: inherit;&#125; 这样设置的好处有： &emsp;&emsp; 1. 子元素的盒模型类型，默认由父元素决定，方便组件统一设置； &emsp;&emsp; 2. 支持低版本的浏览器：Safari (&lt; 5.1), Chrome (&lt; 10), and Firefox (&lt; 29); 问题三：Bootstrap3开始，全局使用IE盒模型（box-sizing取border-box），又是基于怎样的考虑？怎么协调好与基于标准盒模型开发的第三方组件的关系？ 众所周知，BS2还考虑对IE7的兼容，而BS3彻底放弃了对IE7的兼容，并将box-sizing设置为border-box。关于这一点，可见“Bootstrap 3 released”官方发布的change list，摘录如下： 从以上直白的表述中：Better box model by default（默认使用更好的盒模型），我们可以看出BS作者是IE盒模型的拥趸。作者也把理由罗列了出来，其核心内容也是如前面所提到的，IE盒模型在响应式布局上的良好表现。补充的一点是，如果不全局设置border-box，而每个组件及其子组件单独设置，维护起来将是个梦魇（作者在官方编号为12351的issure中有提到）。 而关于BS如何处理好与基于标准盒模型开发的第三方组件的关系，亦可参见编号为12351的issue：”Move away from * {box-sizing: border-box } to play nice with 3rd party scripts” 作者在issue中，霸气又委婉地回应： &emsp;&emsp; 1. BS并不考虑对第三方组件和框架的支持。作者委婉地说，BS是一个大项目，活跃维护者也主要是四个人，顾不来所有人的需求啊～（但感觉作者是在说，BS是个又大又全的框架，你丫还搞第三方组件干嘛呀） &emsp;&emsp; 2. IE盒模型，用了大家都说好，为什么第三方组件不转过来支持IE盒模型啊（果然是铁粉） 本章节从box-sizing的作用、浏览器兼容性、产生原因、评价和最佳实践这5个切入点，来讲解box-sizing属性，以期加深各位同学对这个属性的理解和掌握。特别要强调的一点是，如果刚接手某个项目，在编写CSS代码前，先看看项目是否有全局配置box-sizing，并根据具体的取值来选用相应的尺寸计算规则。 元素的分类及其布局特性1. 元素的分类从元素的布局特性来分，主要可以分为三类元素：block-level（块级）元素、inline-level（行内级）元素和inline-block-level（行内块级）元素，我们可以对其下个定义： 1.1. 块级元素display属性取block、table、flex、grid和list-item等值的独占一行显示的元素。1.2. 行内级元素display属性取inline值的可在同一行内排列显示的元素。1.3. 行内块级元素 display属性取inline-block、inline-table、inline-flex和inline-grid等值的兼具块级元素和行内级元素布局特性的元素。 友情提示： 1）关于各类元素display的取值，实际已全部罗列，但为了保证定义能拥抱变化（未来可能引入新的display属性值），在罗列时使用了等字； 2）w3c官方文档，把display属性值为inline、inline-block、inline-table的元素，统称为inline-level元素，我不太喜欢也不太认可这种泛泛的分类，本文重新定义了一个“inline-block-level元素”的概念，来对“inline-level元素”进行了细分，并将inline-blocks、inline-tables单独分类为inline-block-level元素，原文档如下：“The following values of the ‘display’ property make an element inline-level: ‘inline’, ‘inline-table’, and ‘inline-block’.” 2. 元素的布局特性2.1. 块级元素（block-level）的布局特性对于块级元素，有如下几个布局特性： &emsp;&emsp; 1. 独占一行（width默认为100%，height为0）；&emsp;&emsp; 2. 可以设置任何尺寸相关的属性（width、padding、margin和border）； 2.2. 行内级元素（inline-level）的布局特性在讲行内级元素的布局特性之前，我们先了解一下行内级元素的分类，其可再细分两类元素： 1）可置换行内元素 在MDN中，其对“可置换行内元素”的定义如下： 按字面翻译，“可置换行内元素”，是展示内容不在CSS作用域内的元素。这句话是不是不好理解？我们可以换另外一种方式理解：“可置换行内元素”，是这样一类元素，其展示的内容是通过元素的src、value等属性或CSS content属性从外部引用得到的，可被替换的。随着内容来源或内容数量的变化，可置换元素本身也会有水平和垂直方向上尺寸的变化。典型的可替换元素有 &lt;img&gt;、 &lt;object&gt;、 &lt;video&gt; 和 &lt;embed&gt;，表单类的可替换元素有&lt;textarea&gt; 和&lt;input&gt; ，某些元素只在一些特殊情况下表现为可替换元素，例如 &lt;audio&gt; 、&lt;object&gt;、&lt;canvas&gt;和&lt;applet&gt;。 特别地，通过 CSS content 属性来插入的对象又被称作 匿名可置换元素。 2）不可置换行内元素 不可置换行内元素其实就是我们常见的一类行内元素，这一类行内元素有和等。不可置换行内元素是相对于“可置换行内元素的，其展示的内容是在CSS作用域范围内的，是不可替换的。 言归正传，行内级元素有如下几个布局特性： &emsp;&emsp; 1. 在一行内可以与多个同类型的元素按从左到右的顺序排列；&emsp;&emsp; 2. 不可置换行内元素不能设置width、height和垂直方向上的margin，而可置换行内元素则可以；&emsp;&emsp; 3. 在水平和垂直方向上的对齐方式，行内级元素分别受父元素的text-align属性和自身vertical-align属性的控制（父元素是table-cell元素时，也受父元素的vertical-align属性控制），在水平方向上默认左对齐，在垂直方向上默认在行框的baseline基线上显示（“行框”的概念，会在后面深入讲解)； 友情提示： 1）有时候我们不必太纠结于哪些行内元素是可置换行内元素，因为有些浏览器（如chrome）的默认样式(user agent stylesheet)，会将这一类元素重置为inline-block元素，我们可以统一把可置换行内元素理解为inline-block元素，因为其布局特性与inline-block-level元素相同。 2）当inline-level元素水平排列时，两两之间可能会出现大约6px的空白，这是由元素间的空白字符（换行符、空格或制表符）产生，如下图所示： 清除方法有很多，本人习惯用浮动的方式来处理，其它方法可自行google。 2.3. 行内块级元素（inline-block-level）的布局特性行内块级元素兼具block-level元素和inline-level元素的布局特性，主要体现为： &emsp;&emsp; 1. 排列方式与行内级元素同，不独占一行，在一行内按从左到右的顺序排列；&emsp;&emsp; 2. 水平和垂直方向上的对齐方式与行内级元素同；&emsp;&emsp; 3. 和块级元素一样，可以设置任何尺寸属性（但width默认为0）； 注：我们不难发现，其实可置换行内元素，其布局特性与inline-block-level元素相同。 格式化上下文（Formatting Context）格式化上下文，它指的是具有某种CSS格式化规则（布局规则）的上下文环境，在这个上下文环境内的所有子元素，都将根据其特定的CSS格式化规则来进行排列。 我们可以给某个作为容器的元素指定特定的格式化上下文，也就是说我们可以定义一个具有特定布局规则的渲染区域。常见的格式化上下文有BFC（CSS2.1 规范）、IFC（CSS2.1 规范）、 FFC（CSS3规范新增）和GFC（CSS3规范新增），具体介绍如下： 1. BFC1.1. 定义BFC, 全称是block formatting context，它是一个独立封闭的渲染区域，在这个区域内的所有元素，从区域的顶部起，一个接一个地根据自身的布局特性进行排列：在这个区域内的块级元素 ，按从上到下的顺序显示，相邻的块级元素可以使用margin隔离，但在垂直方向上相邻的块级元素会发生margin合并；在这个区域内的inline-level或inline-level-block元素，则按从左到右的顺序显示（W3C组织说BFC内部的元素都是一个接一个地垂直显示，我觉得不是很严格，因为BFC内部也可以容纳inline-level和inline-level-block元素，所以这里我的解释和W3C还是稍微有一些不一样）。具有BFC格式化环境的元素，我们称之为BFC元素，可以说，BFC定义了BFC元素content区域的渲染规则。 看到这段描述，是不是觉得BFC的渲染规则，不就是文档流的默认布局规则吗？确实很像，但不完全等同。BFC元素内部的渲染规则和普通块级元素内部的渲染规则，还是有一些不同的，我们将在5.4.1.3. 特性一节详述。 1.2. 创建方式创建BFC元素的方式有如下几种（摘自MDN BFC）： 根元素或其它包含它的元素 浮动元素 (元素的 float 不是 none) 绝对定位元素 (元素的 position 为 absolute 或 fixed) 内联块 (元素具有 display: inline-block) 表格单元格 (元素具有 display: table-cell，HTML表格单元格默认属性) 表格标题 (元素具有 display: table-caption, HTML表格标题默认属性) overflow 值不为 visible 的块元素 display: flow-root contain为以下值的元素: layout, content, 或 strict 弹性项 (display: flex 或 inline-flex元素的子元素) 网格项 (display: grid 或 inline-grid 元素的子元素) 多列容器 (元素的 column-count 或 column-width 不为 auto， 包括 column-count: 1的元素) column-span: all应当总是会创建一个新的格式化上下文，即便具有 column-span: all 的元素并不被包裹在一个多列容器中。 1.3. 特性BFC元素具有如下特性： &emsp;&emsp; 1. 对应一个独立、封闭的渲染区域，子元素的CSS样式不会影响BFC元素外部； 举个例子，我们分别用连续的两个块级元素，一个是普通块级元素，另一个是BFC元素（均使用绿色背景），分别包裹一个margin-top为20px的子元素（黄色背景），对比其布局效果： 说明： 普通块级元素，其子元素的margin-top，不会隔开自身与父元素（普通块级元素），但是会作用到父元素外部（将父元素和叔伯元素或祖父元素隔开）； BFC元素，作为一个独立、封闭的渲染区域，其子元素的margin-top，则会隔开自身与父元素（BFC元素），而不会影响到父元素外部； &emsp;&emsp; 2. 浮动子元素参与BFC父元素的高度计算，也就是BFC元素能够识别浮动元素（将元素声明为BFC元素，也是clearfix解决父元素塌陷问题的一种常用方法）； 举个例子： 说明： 普通块级元素，不能够识别浮动的兄弟元素，会被浮动的兄弟元素覆盖部分内容； 占据文档流的BFC元素（可使用overflow: auto创建），能够识别浮动的兄弟元素，不会被浮动的兄弟元素覆盖，与之同行显示； &emsp;&emsp; 3. 占据文档流的BFC元素（可使用overflow: auto创建），width为auto时，会占满当前行的剩余宽度； 举个例子： 说明： 文档流中的BFC元素, width为auto时，会占满当前行的剩余宽度； 2. IFC2.1. 定义IFC, 全称是inline formatting context，其内部的元素，在水平方向上，一个接一个地显示；在垂直方向上，每个元素可以设置不同的对齐方式；IFC内部的元素，被一行行的矩形框所包含，这些虚拟的矩形框，我们称为行框（line box）。IFC的作用区域，可以看成是包含其所有子元素的行框组成的矩形区域。 2.2. 创建方式和BFC相比，它的创建方式是被动的、隐式的，是由所包含的子元素来创建：只有在一个区域内仅包含可水平排列的元素时才会生成，这些子元素可以是文本、inline-level元素或inline-block-level元素。 2.3. 特性&emsp;&emsp; 1. IFC内部的元素，按从左到右、从上到下的顺序排布； &emsp;&emsp; 2. IFC内部的每个元素，都可以通过设置vertical-align属性，来调整在垂直方向上的对齐； &emsp;&emsp; 3. 包含这些内部元素的矩形区域，形成的每一行，被称为line box（行框，后面会详细介绍）； 3. FFC和GFCFFC（flex formatting context）和GFC（grid formatting context），分别是flex布局和grid布局的内容，这两个模块的内容非本文介绍的重点，所以感兴趣的同学可以自行google。 包含块（Containing Block）1. 定义我们在设置元素尺寸属性（width、height、padding、margin和border）的百分比值或偏移属性（top、right、bottom和left）的值时，通常会有一个“相对参考系”，这个”相对参考系”一般是包裹着这个元素的块级祖先元素（一般是块级父元素）或离这个元素最近的非static（relative、absolute和fixed）定位的祖先元素。这些具有“相对参考系”作用的祖先元素，其容纳区域（cotent box或padding box），其实还有一个专门术语形容之，那就是包含块（在知识体系中有个包含块的概念，有助于加深对position定位原理的掌握）。 特别地，relative定位元素，其尺寸属性（width、height等）的“相对坐标系”仍是其包含块（块级祖先元素（一般是父元素）的content box），但是偏移属性（top、right、bottom和left）的“相对坐标系”则是其在文档流原来的位置。 2. ICB（initial containing block, 初始包含块）2.1. 定义如前面所说，任何一个元素都会有一个包含块作为设置尺寸属性和偏移属性的“相对参考系”，而对于顶层的根元素，没有任何元素包裹它，它的包含块是什么？它选取什么作为“相对参考系”？ 其实根元素是有包含块的，它是一个不可见的矩形框，W3C组织称之为ICB（initial containing block, 初始包含块）。以下是W3C组织对ICB对定义： The containing block in which the root element lives is a rectangle called the initial containing block. 2.2. ICB的尺寸和起始位置（左上角坐标）在解释ICB的尺寸和起始位置时，在这里先简单补充一个背景知识：连续媒体（continuous media）和分页媒体（paged media）。如何理解这两个概念？在视觉阅读层面，它们是展示内容的两种呈现方式。 连续媒体，就是采用连续展示内容的方式，它保持了展示内容显示的连续性（一页显示所有内容），我们可以在连续媒体的viewport（可视窗口）查看当前呈现的内容。特别地，浏览器窗口就可以看成是连续媒体，当内容的尺寸超过viewport时，读者可以通过平滑滚动的方式来阅读内容。 分页媒体，就是采用切页展示内容的方式，它将要展示的内容切分为等尺寸的多页（分页显示所有内容），我们可以在分页媒体的page area（页面显示区域）查看当前呈现的内容。特别地，像幻灯片、电子书阅读器，就可以看成是分页媒体，当内容的尺寸超过page area时，读者可以通过切页的方式来阅读内容； 对于属于连续媒体（continuous media）的浏览器窗口来说，ICB的尺寸为viewport（浏览器视窗），其起始位置为画布原点（canvas origin，即首屏的左上角，浏览器渲染数据后生成的内容文档可以看成是一张画布）。 对于分页媒体来说，ICB的尺寸为page area（关于ICB在分页媒体的起始位置，没有找到相关资料，但这个对于本文来说也不是重点）。 直观来看，根元素的包含块ICB，就是“首屏”。 3. 不同定位元素分别对应的包含块 static和relative定位元素的包含块，为其块级祖先元素（通常是块级父元素）的content box； absolute定位元素的包含块，为最近的非静态定位祖先元素的padding box，查无非静态定位祖先元素，那么它的包含块是ICB（即根元素的包含块）； fix定位元素的包含块，为当前viewport（视窗）； 在这里要强调的一点，ICB（初始包含块）是专有名词，它特指根元素的包含块。不要将一个元素的初始包含块，错误理解为它的父元素。MDN的一位编辑者也犯了这种错误。具体如下： 经修正后： 也有一些权威CSS书籍说，当一个绝对定位元素找不到最近的非static祖先元素时，则相对于根元素定位，这种说法也是不严谨的。刚好看到一本，如下： 我们可以通过一个简单的例子推翻这种说法：将根元素html的高度设置为超过viewport高度，如5000px（假设viewport高度为500px），再将一个没有最近的非static祖先元素的绝对定位元素的bottom设置为0，尺寸为100px100px即可。如果真如该书中所言，那么在首屏时，该绝对定位元素是被隐藏在滚动条下面的。而实际情况是：该绝对定位元素必然出现在首屏的底端，并且会随着页面滚动而滚动。验证如下： 相信这个谬误在前端圈流传已久，希望各位同学引起重视。 基本原理1. 文档流（正常流）1.1. 定义关于“文档流”，并没有找到较为官方的定义。笔者从google搜到一些认为比较靠谱的解释，罗列如下： The document flow is the model by which elements are rendered by default in the CSS specifications. In this model, elements are rendered according by their default display rule. In other words, block-level elements are displayed on a new line and inline elements on the same line. Everything is stacked in an ordered way from top to bottom. 摘自：《CSS: understanding the document flow》 Document flow is the arrangement of page elements as defined by positioning statements and the order of html statements; that is, how the different elements take up space and arrange themselves around each other.摘自：《What is “document flow”?》 在这里我想分享一下我自己对“文档流”下的定义： 文档流，是页面元素默认存放的“容器”。 1.2. 特性文档流具有如下特性： 文档流按照页面元素书写的顺序，将页面元素按从左到右，从上至下的一般顺序进行排列，而页面元素则根据自身的布局属性(block-box or inline-box)，决定是行内显示，还是换行显示; 文档流内的元素，相互尊重：有序排列，彼此识别； 1.3. 脱离文档流元素脱离文档流，按我之前下的定义，其实就意味着：元素脱离了默认存放的容器，换到另外一个容器存放。一个元素脱离了文档流，这样会导致：其父元素无法识别其，其也不参与父元素高度的计算。若有一个父元素的所有子元素都脱离文档流，则会出现“高度塌陷”问题。常见的脱离文档流的方法有： 将元素设置为浮动元素 将元素设置为absolute、fixed元素 2. 浮动（float属性）2.1. 浮动元素的分类根据float属性的设置，元素可以分为浮动元素（值为left或right）和非浮动元素（值为none）。而按浮动方向划分，又可细分为： 左浮动元素：float值为left的元素 右浮动元素：float值为right的元素 2.2. 浮动原理要想掌握浮动元素的浮动原理，只要理解浮动元素的浮动起始位置、浮动方向和浮动结束位置即可。 浮动起始位置浮动元素（包括左右）的浮动起始位置，为最后一行最左侧的空白位置，而不管空白位置是否能够容纳当前浮动元素； 浮动方向左浮动元素的浮动方向为从起始位置向左浮动； 右浮动元素的浮动方向为从起始位置向右浮动； 浮动结束位置左浮动元素遇到第一个左浮动元素或包含块的最左侧padding时，结束浮动； 右浮动元素遇到第一个右浮动元素或包含块的最右侧padding时，结束浮动； 以下demo可以帮助各位同学理解浮动元素的三要素： /06:layout/float/1. 浮动元素三要素.html: 123456789&lt;body&gt; &lt;div class="fl"&gt;左浮动元素－1（width: 30%; height: 100px;）&lt;/div&gt; &lt;div class="fl"&gt;左浮动元素－2（width: 30%; height: 200px;）&lt;/div&gt; &lt;div class="fl"&gt;左浮动元素－3（width: 30%; height: 100px;）&lt;/div&gt; &lt;div class="fl"&gt;左浮动元素－4（width: 30%; height: 100px;）&lt;/div&gt;&lt;/body&gt;&#125; 显示结果： 说明： a. 有四个连续左浮动的元素，每个元素宽度为30%； b. 当一行排满三个元素时，当前行只剩10%的宽度，不足以容纳第四个左浮动元素; c. 第四个浮动元素，从起始位置（最后一行的最左侧空白）开始向左浮动，直到遇到第二个浮动元素的边界; 为了帮助大家理解好浮动原理，在这里我想额外定义几个术语： 左浮动队：由若干个连续的左浮动元素组成 右浮动队：由若干个连续的右浮动元素组成 左浮动队头元素：左浮动队的第一个元素，也是最左侧的元素 右浮动队头元素：右浮动队的第一个元素，也是最右侧的元素 特别地， 同一行内，最多有两条浮动队，一是左浮动队，二是右浮动队； 同一行内，一条浮动队可能占满一行； 连续浮动的若干元素，如果无法在同一行内显示，则会按行被切分为两条或更多条浮动队； 5.6.2.3. 浮动对元素display的影响 当元素设置为浮动元素后，可能会引发display属性的值变化，具体规则如下： 3. 清除浮动（clear属性）3.1. 三要素清除浮动，其作用是改变“当前元素”与“前一个声明的浮动元素”之间的默认布局规则，这种改变主要体现为：让当前元素换行显示。这句话包含三个要素，分别为： 使用者：当前元素（浮动元素或者非浮动元素的块级元素） 作用对象（清除谁的浮动）：前一个声明的浮动元素 目的（作用）：让当前元素换行显示 特别地，为什么使用者不包括非浮动的inline元素？因为非浮动的inline元素能够识别浮动元素，是否使用clear清除“前一个声明的浮动元素”的浮动，其布局结果是一样的。感兴趣的同学可以参考： 06:layout/clear/4.非浮动inline元素清除左浮动.html， 可以在调试器中观察注释非浮动inline元素的clear:left前后，其显示位置的变化。而非浮动的块级元素，因为无法识别前面声明的左浮动元素，故会和左浮动元素发生重叠（左浮动元素在上），所以非浮动的块级元素使用clear：left清除前一个左浮动元素，就能避免重叠的现象。 3.2. clear属性的取值及应用场景前面简单介绍了clear属性的作用，是清除前面声明的浮动元素的浮动，然后让当前元素换行显示。但是要具体怎么使用，我们还得深入到clear的属性值和应用场景。 clear属性的取值有left、right和both。那么它们的应用场景分别是什么？ left值的应用场景是，前面声明的浮动元素是向左浮动（float: left）; right的应用场景是，前面声明的浮动元素是向右浮动（float: right）; both的应用场景是，前面声明的浮动元素的浮动方向不确定，可能是左，也可能是右（了解过clearfix实现原理的同学，就不难明白）； 再次强调一下，当前元素如果要清除浮动，清除的是前面声明的浮动元素的浮动，其clear属性要取什么值，跟当前元素的是否是浮动元素或浮动方向没有任何关系，而取决于其前面声明的浮动元素的浮动方向。 举个例子，一个右浮动元素（float：right），前面有一个左浮动元素（float：left），如果这个右浮动元素使用clear: left时，这个元素会清除前一个元素的浮动，进而换行显示；如果使用clear：left时，这个元素在当前行的最右端显示。如下图所示 06:layout/clear/4.右浮动清除左浮动.html： 在了解完clear属性的取值和应用场景，我们可以对其作用，可以总结为： 如果当前元素浮动元素或非浮动的块级元素，且前面声明的元素是左（右）浮动元素，那么当前元素可以使用clear: left（clear: right），清除前一个左（右）浮动元素的左（右）浮动，此时当前元素会换行显示；如果当前元素clear的浮动与前面一个浮动元素的浮动方向不同向，当前元素不会换行； 3.3. 清除浮动后的margin合并问题1）两个浮动元素之间，其垂直方向上的margin不会发生合并，如下图所示： 2）非浮动的块级元素和浮动元素之间，其垂直方向上的margin会发生合并，如下图所示： 特别地，MDN的文档说非浮动的块级元素与浮动元素间不会发生margin合并，实际上会，上述结果已经证明，已在MDN上更正该错误。以下为MDN未修改前的原话： 3.4. 清除浮动的特殊应用：解决父元素高度塌陷问题众所周知，当一个父元素里面的所有元素都是浮动元素时，此时父元素无法识别这些浮动子元素，会进一步导致父元素发生高度塌陷问题。一种通用的解决方案就是在父元素内部的尾部append一个非浮动的、尺寸为0的块级元素（后面简称fix元素），然后使用clear：both，让这个fix元素换行显示，进而让父元素能够识别前一行的高度。这种朴素的方案其实就是clearfix的基本原理，clearfix只是更加优雅地用:after来实现fix元素。 特别说明：解决父元素高度塌陷问题，还可以通过将父元素声明为BFC元素来实现。 4. 定位（position属性）4.1. 定位元素的分类根据position属性的取值，static（默认值）、relative、absolute、fixed，元素可以分为静态定位元素（值为static）、相对定位元素（值为relative）、绝对定位元素（值为absoute）和固定定位元素（值为fixed）。 注：position的取值还有sticky，但IE11都不支持，此处不讲 4.2. 定位原理static定位元素定位时的相对坐标系：无法设置top、right、bottom和left这四个偏移属性； relative定位元素定位时的相对坐标系：元素在文档流原来的位置（区域）； absolute定位元素定位时的相对坐标系：离元素最近的一个非static（包含relative、absolute和fixed）定位祖先元素（包含块为其padding box），如果没有则为ICB（初始包含块），即根元素html的包含块； fixed定位元素定位时的相对坐标系：当前的视窗（viewport）； 5. line box（行框）5.1. 定义前面在介绍IFC时，我们提到过line box的定义：包含IFC内部的所有子元素的虚拟矩形区域，形成的每一行，称为line box。由于它是矩形的，中文常见将之翻译为行框。 5.2. 模型结构（七线谱）line box的模型结构，形如七线谱，其中有六条重要的线：top线、text-top线、middle线、baseline线、text-bottom线和bottom线，如下图所示： 其中top线到text-top线的区域和bottom线到text-bottom的区域，又称为行半距（half-leading），两个行半距之和，为一个行距；text-top线到text-bottom线的区域，称之为内容区域（content-area）。如下图所示： 5.3. 行框高度的计算行框的高度，即一行的top线和bottom线间的垂直距离，这个垂直距离为：上下两个行半距的高度和一个内容区域的高度之和。影响行框高度计算的因素来自两方面，一是自身line-height属性的设置，二是内部inline-level子元素的margin box高度的取值和line-height、vertical-align两个属性的设置。关于其计算规则，具体罗列如下： &emsp;&emsp; 1. 一个元素的行框高度，可由该元素的line-height属性设置； &emsp;&emsp; 2. 一个元素的行框高度，受不可置换（span、a、label等）的子元素的内容高度（text-top到text-bottom的垂直距离）影响（内容高度又受font-size属性和浏览器的解析规则影响，但主要由font-size决定；相同的font-size，在不同的浏览器，计算出来的内容高度也不一样，最终导致的行框高度也不一样）； &emsp;&emsp; 3. 一个元素的行框高度，可由不可置换（span、a、label等）的子元素的line-height属性设置； &emsp;&emsp; 4. 一个元素的行框高度，可由可置换行内元素（如img）或display属性为inline-block、inline-table的这一类inline-block-level子元素的margin box高度和vertical-align属性决定，当vertical-align为top或bottom时，行框的高度达到最小，刚好为子元素的margin box高度； &emsp;&emsp; 1. 如果同时满足以上设置条件，那么行框的高度取最大值；友情提示：在图1img元素的margin box高度比行框高度小，我们会看到img元素到父元素的底端会有一段空白，为什么会有这种现象？张鑫旭老师在《CSS深入理解vertical-align和line-height的基友关系》一文中将之定义为“幽灵空白节点”，其实结合行框理论来解释，这段空白并不“幽灵”，也很好理解：它是行框的baseline线到bottom线的垂直距离，可置行内换元素如img和inline-block-level元素，在被浏览器解析时，会和“文本”一样，默认在baseline线上显示，而不是在行框的bottom线上。 举个例子: 行框高度的计算 html: 1234567891011121314151617181920212223242526272829303132333435363738 &lt;style&gt; .line-box &#123; background: yellow; line-height: 32px; font-size: 20px; &#125; .span-1 &#123; line-height: 40px; background: red; &#125; .span-2 &#123; line-height: 38px; background: green; &#125; img &#123; width: 50px; height: 50px; &#125; &lt;/style&gt; &lt;body&gt; &lt;div class="line-box"&gt; &lt;span class="span-1"&gt;span(line-height: 40px)&lt;/span&gt; &lt;span class="span-2"&gt;span(line-height: 38px)&lt;/span&gt; &lt;/div&gt; &lt;div class="line-box"&gt; &lt;span class="span-1"&gt;span(line-height: 40px)&lt;/span&gt; &lt;span class="span-2"&gt;span(line-height: 38px)&lt;/span&gt; &lt;img src="#" /&gt; &lt;/div&gt; &lt;/body&gt;&#125; 显示结果（chrome下）： line box内部仅有不可置换元素 说明： a. 元素每一行的line-height，既可以由当前元素的line-height属性设置（32px），也可以由该行子元素的line-height属性设置（分别是40px和38px），但取最大的line-height（40px），如图1所示； b. 特别地，如果一行内还有可以设置height的可置换元素如img（height: 50px），且img的高度大于设置的最大line-height（40px）时，那么该行会被撑高，浏览器会重新计算line-height(最终结果为63px)，如图2所示； 5.4. 与line box行框有关的两个重要属性：line-height和vertical-align相信很多前端同学有这样的感觉：line-height和vertical-align这两个属性总是形影不离，而且有着一种说不清的关系。 它们到底有什么联系吗？ 其实这两个属性的关系可由行框和行框内的inline-level元素来体现。line-height属性决定inline-level元素所在行框的高度，它是inline-level元素在一行内垂直方向上的显示范围；vertical-align属性则决定inline-level元素在一行内的垂直对齐方式，即决定inline-level元素在一行内垂直方向上的最终位置。下面我们来深入介绍这两个属性： 1）line-height属性 1.1）line-height属性的作用 line-height属性一般用于块级元素设置其内部每一行的高度，即默认行高；line-height属性也可以用于不可置换元素（如span、a）设置所在行框的高度。也就说，每一行计算出来的最终行高，既受父元素line-height属性的影响，也受子元素line-height属性的影响。 1.2）line-height属性的取值 line-height的取值有、、和关键字normal（默认值）。其中： 表示使用指定带单位的长度来设置line-height，这些长度单位可以是px、pt和em和rem； 表示用font-size值的倍数来设置line-height； 表示用font-size值的百分比来设置line-height； 而关键字normal，其最终计算出来的尺寸，则取决于浏览器各自的解析机制和选用的font-family类型：浏览器会根据选用的font-family类型来计算出一个合适的值，W3C官方推荐使用值，并且推荐值的范围为1.0到1.2之间（但经过实测，浏览器在实现时，远比这个复杂，而且不同浏览器间也存在差异。唯一可以确定的一点是，最终的行高肯定会比font-size值要大）。 我们在将UI稿实现为页面代码时，常常强调要Pixel Perfect、高精准地还原设计稿。但 我们常常会遇到这样一个问题：当我们用一个块级元素包裹文本时，会发现块级元素的高度，实际比文本的font-size尺寸还要高，导致上下形成了一些空白，进一步造成块级元素内的文本与垂直方向上相邻元素的距离变大，如下图所示： 这种误差是由于line-height的默认值为normal，那有什么办法可以解决这个问题呢？较常用的方法是将块级元素的line-height设置为1或100%。设置后的结果如下图所示 这样做也有一点不好，那就是：浏览器最终解析出来的内容高度，有可能是比font-size要大的，当行高为font-size时，文本内容就会溢出。我们将字体放大为100px，溢出效果就很明显，如下图所示：x31 1.2）line-height属性对元素高度的影响 我们可以通过了解line-height属性分别对块元素和不可置换的行内元素自身高度的影响、以及不可置换的子元素的line-height属性对父元素高度的影响，来深入理解line-height属性的作用。 为了帮助大家更好地理解line-height，我设计了如下三个小demo： demo1: line-height属性对块级元素自身height的影响 html: 123456789101112131415161718 &lt;body&gt; // div为单行 &lt;div class="block"&gt; div(line-height: 32px) &lt;/div&gt; // div为多行 &lt;div class="block"&gt; div(line-height: 32px) &lt;br&gt; div(line-height: 32px) &lt;/div&gt; &lt;/body&gt;&#125; 显示结果（chrome下）： 说明： a. 当一个块元素不设置height，而且这个块元素仅有一行时，那么其height刚好等于line-height； b. 当一个块元素不设置height，而且这个块元素有多行时，那么其height刚好等于每一行的line-height之和； demo2: line-height属性对不可置换行内元素（如span）的height的影响 html： 12345678 &lt;div class="line-box"&gt; &lt;span class="inline-element"&gt; span(line-height: 40px;font-size: 20px) &lt;/span&gt; &lt;/div&gt;&#125; 显示结果（chrome下）： 说明： a. 不可置换行内元素为单行时，其height等于text-top线到text-bottom线的距离，所以line-height的取值不会影响到其height，其height由font-size和浏览器的默认解析机制决定（一般&gt;font-size，大多少则取决于浏览器解析机制，如图1、2所示）； b. 不可置换元素为多行时，其height等于第一行的text-top线到最后一行的text-bottom线的距离，此时line-height的取值就会影响到其height，其height＝line-height 行数 - (line-height - 每一行text-top线到text-bottom的距离)，即height＝line-height 行数 - 2 * half-heading；如下图所示： demo3：不可置换的子元素（如span）的line-height，对父元素height的影响 html: 123456789 &lt;div class="line-box"&gt; &lt;span class="span-1"&gt;span(line-height: 40px)&lt;/span&gt; &lt;span class="span-2"&gt;span(line-height: 38px)&lt;/span&gt; &lt;br&gt; &lt;span class="span-3"&gt;span(line-height: 50px)&lt;/span&gt; &lt;/div&gt;&#125; 显示结果（chrome下）： 说明： a. 块级元素每一行的行高都可以不同; b. 不可置换的行内子元素的line-height属性，可以决定所在行框的高度; c. 如果一个父元素不设置height，那么其height为所有行的高度之和； d. 不可置换的行内子元素的line-height属性，是通过影响行框的高度来影响父元素的高度的。 2）vertical-align属性 vertical-align的作用之一：就是用于设置inline-level元素自身在“行框”内的垂直对齐方式，其控制范围在一行内。较常用的值有top、middle、baseline（默认值）和bottom，不常用的有text-top、text-bottom、sub和super，几乎不用的有和。 vertical-align属性的几个重要取值的作用如下： 当vertical-align取top时，表示当前inline-level元素的上margin edge在行框内贴顶； 当vertical-align取bottom时，表示当前inline-level元素的下margin edge在行框内贴底； 当vertical-align取middle时，表示当前inline-level元素的垂直平分线和行框的middle线重合； 当vertical-align取baseline时，表示当前inline-level元素的下margin edge紧贴在行框的baseline上； vertical-align属性的另一个作用：就是table-cell元素用于控制其内部子元素在垂直方向上的对齐方式，而且这些子元素的类型不受限制，不仅可以是span，而且可以是div。 举个例子： html： 1234567891011 &lt;table&gt; &lt;tr&gt; &lt;td class="top"&gt;div(top)&lt;/td&gt; &lt;td class="middle"&gt;div(middle)&lt;/td&gt; &lt;td class="baseline"&gt;div(baseline)&lt;/td&gt; &lt;td class="bottom"&gt;div(bottom)&lt;/td&gt; &lt;/tr&gt; &lt;/table&gt;&#125; 显示结果： 说明： a. table-cell元素通过设置自身的vertical-align属性，来设置其子元素在垂直方向上的对齐方式； 特别说明：我们常用说的使用table布局来实现子元素在父元素内部垂直居中，就是运用到了这个知识点。 6. margin在传统的布局方案中，margin不仅用来隔离自身与相邻元素或父元素（一般不推荐用来隔离父元素），而且在元素水平和垂直方向上的居中定位，亦发挥了重要的作用。下面我们来深入介绍margin的相关布局特性。 6.1. auto的计算规则（在width和margin上使用）1）水平方向上 谈到“如何设置文档流中的块级元素在父元素内部水平居中？”这个布局问题，相信很多同学马上会想到这个方案：给元素设置固定宽度，并使用margin: 0 auto（水平方向上的margin为auto） 1234567 .child&#123; width:100px; margin:0 auto; &#125;&#125; 它的实现原理，包含如下四个基础知识点： 块级元素的水平尺寸（outerWidth，margin box的宽度）的计算规则： 1234 outerWidth = margin-left + border-left-width + padding-left + width + padding-right + border-right + margin-right， &#125; 如下图所示： 文档流中的块级元素，其在水平方向上的尺寸属性的初始值，仅width为auto，其余为0 在水平方向上的尺寸属性，仅width、margin-left和margin-right可以设置auto值（自动计算） 文档流中的块级元素，其在水平方向上的尺寸属性，当值为auto时，表示取所在行的剩余宽度，特别地，当margin-left和margin-right的值均为auto时，会平分所在行的剩余宽度 在理解了上述四个基础知识点，我们不难理解其原理： 当块级元素在水平方向上的尺寸属性，除了margin-left和margin-right值为auto，其余皆为定值，那么margin-left和margin-right会自动平分父元素的剩余宽度，进而达到在父元素内部水平居中的效果，如下图所示： 结合上述四个基础知识点，我们还可以得出如下结论： 文档流中的块级元素如果不设置任何水平尺寸属性，那么其默认的width为当前行的content width，此时width取auto和100%，最终的计算值一样 2）垂直方向上 或许我们都曾问过这样的一个问题：既然可以通过设置margin: 0 auto，让文档流中的块级元素在父元素内部水平居中，那么可否通过设置margin: auto 0，让其垂直居中？ 答案是不能的，因为文档流中的块级元素，其垂直方向上的margin为auto时的计算规则和在水平方向上的计算规则不同：不取父元素剩余的高度，而为0。W3C标准原话如下： “If “margin-top” or “margin-bottom” is “auto”, their used value is 0″ 或许大家会问，为什么要这样设计呢？官方并没有给出说明，但是有网友给出了如下几个解释，罗列如下，供各位参考（可以在留言中分享你的看法，本人比较认同第一条）： It could be because of the typical vertical page flow, where page size &gt;increases height-wise. So, centering an element vertically in its container is not going to make it appear centered, relative to the page itself, unlike when it’s done horizontally (in most cases). And maybe it’s because of this same reason, they decided to add an exception for absolute elements which can be centered vertically along the entire page’s height. It could also be because of the margin collapse effect (a collapse of adjacent elements” margins) which is another exception for the vertical margins. 在W3C标准规约中，虽不能使用margin: auto 0，实现普通文档流中的块级元素在父元素内部垂直居中，但是可以使用margin: auto 0，实现绝对或固定定位元素在包含块内部垂直居中，因为绝对或固定定位元素垂直方向上的margin，其 auto仍会取包含块的剩余高度，W3C官方文档给出的计算公式如下： 1234 'top' + 'margin-top' + 'border-top-width' + 'padding-top' + 'height' + 'padding-bottom' + 'border-bottom-width' + 'margin-bottom' + 'bottom' = height of containing block &#125; 等价的简化公式： 子元素outerHeight = 包含块height - 子元素top - 子元素bottom 提示： &emsp;&emsp; 1. 子元素outerHeight，是指当前子元素margin box的高度； &emsp;&emsp; 2. 包含块height，可以为当前子元素的相对定位参考系元素的padding box的高度、ICB的高度或viewport的高度； 要使用上述规则来实现子元素在父元素内部垂直居中，那么就需要保证： 子元素的top值 + bottom值为0（原因：让子元素outerHeight 等于包含块height） 子元素的top值取0（原因：让子元素的上margin edge紧贴包含块的顶部） 下面通过一个demo来详细介绍： html: 1234567891011121314151617181920212223242526 &lt;style&gt; .parent&#123; position:relative; background:yellow; height:100px; &#125; .child&#123; position:absolute; top:0; bottom:0; background:green; width:140px; height:20px; margin:auto 0; text-align:center; &#125; &lt;/style&gt; &lt;body&gt; &lt;div class="parent"&gt; &lt;div class="child"&gt;垂直居中的子元素&lt;/div&gt; &lt;/div&gt; &lt;/body&gt;&#125; 显示结果： 说明： a. 绝对定位的子元素的top为0，其轮廓（包含margin）的上边界与其包含块内容区域的顶部紧贴； b. 由已知求未知：包含块的height已知，子元素的top值和bottom值之和为0，即子元素的outerHeight可求，又因为子元素height已知，故垂直方向上的剩余高度可以确定，当子元素的margin-top和margin-bottom均为auto时，将平分剩余的高度； 6.2. margin合并（margin collapsing）在垂直方向上，元素与自身或相邻的兄弟元素、父元素、子元素的margin，会发生合并（注意：在IE6/7子元素垂直方向上的margin会隔离父元素，而不是和父元素的margin发生合并，IE8+则与标准浏览器同），margin取较大的值，而在水平方向上则不会。各位读者可以从下面三个demo，来理解垂直方向上margin的合并： 1) 父元素与子元素（第一个子元素、最后一个子元素） html： 12345678 &lt;div class="wrapper"&gt; &lt;div class="parent"&gt; &lt;div class="child first-child"&gt;第一个子元素(margin-top: 20px)&lt;/div&gt; &lt;div class="child last-child"&gt;最后一个子元素(margin-bottom: 20px)&lt;/div&gt; &lt;/div&gt; &lt;/div&gt;&#125; 显示结果： 说明： a. 父元素(黄色)的margin-top(40px)和第一个子元素的margin-top(20px)发生融合(取较大的40px)； b. 父元素(黄色)的margin-bottom(40px)和最后一个子元素的margin-bottom(20px)发生融合(取较大的40px)； 2) 上下相邻的兄弟元素（同层元素） html： 123456 &lt;div class="parent"&gt; &lt;div class="child first-child"&gt;第一个元素(margin-bottom: 40px)&lt;/div&gt; &lt;div class="child last-child"&gt;第二个元素(margin-top: 20px)&lt;/div&gt; &lt;/div&gt;&#125; 显示结果： 说明： a. 第一个元素的margin-bottom(40px)和第二个元素的margin-top(20px)发生融合(取较大的40px)； 3) 空块级元素 html： 1234567 &lt;div class="line"&gt;第一行&lt;/div&gt; &lt;div class="empty-block"&gt;&lt;/div&gt; &lt;div class="line"&gt;第二行&lt;/div&gt;&#125; 显示结果： 说明： a. 两行之间的空白区域，为一个空块元素；b. 空块的margin-top为40px, margin-bottom为20px;c. 两行之间的距离为40px，可知空块元素的margin-top和margin-bottom发生了合并，取较大值； 这里我们举了三个会在垂直方向上发生margin合并的例子，但是细心的同学可能记得，我们在“5.6.3.3. 清除浮动后的margin合并问题”章节，举了一个在垂直方向上例子不会发生margin合并的例子：浮动元素间在垂直方向上不会发生margin合并。 6.3. 子元素的margin隔离父元素细心的读者不难发现，在“2) 上下相邻的兄弟元素（同层元素）” 的demo可以看到 子元素（绿色）垂直方向上的margin并没有将自己与父元素（黄色）隔离开（IE6/7会，IE8+不会）。 那么什么情况，子元素的margin可以和父元素隔离开？ 首先要强调的一点是， 子元素水平方向上的margin，始终能够隔离父元素；然而子元素在垂直方向上的margin隔离父元素的情况，本人记录的仅有以下四种（欢迎补充）： case 1: 父元素是BFC元素 html： 1234&lt;div class="parent"&gt; &lt;div class="child"&gt;子元素(margin: 20px)&lt;/div&gt; &lt;/div&gt; 显示结果： 说明： a. 父元素（黄色）是BFC元素，子元素（绿色）垂直方向上的margin能够隔离父元素； case 2：父元素拥有border html： 1234&lt;div class="parent"&gt; &lt;div class="child"&gt;子元素(margin: 20px)&lt;/div&gt;&lt;/div&gt; 显示结果： 说明： a. 父元素（黄色）拥有border，子元素（绿色）垂直方向上的margin能够隔离父元素； case 3：父元素拥有padding html： 1234&lt;div class="parent"&gt; &lt;div class="child"&gt;子元素(margin: 20px)&lt;/div&gt; &lt;/div&gt; 显示结果： 说明： a. 父元素（黄色）拥有padding，子元素（绿色）垂直方向上的margin能够隔离父元素； case 4：子元素是可置换元素或display为inline-block、inline-table、table-caption的元素 html： 123456789101112131415161718192021222324252627282930313233 &lt;style&gt; .parent&#123; background:yellow; width:100%; height:60px; line-height:20px; &#125; .inline-block&#123; display:inline-block; &#125; .inline-table&#123; display:inline-table; &#125; img,.inline-block,.inline-table&#123; border:1px solid green; height:20px; min-width:20px; margin-top:10px; vertical-align:top; &#125;&lt;/style&gt;&lt;body&gt; &lt;div class="parent"&gt; &lt;img src="frame_image.svg" /&gt; &lt;div class="inline-block"&gt;display: inline-block &lt;/div&gt; &lt;div class="inline-table"&gt;display: inline-table&lt;/div&gt; &lt;/div&gt;&lt;/body&gt; 显示结果： 说明： a. 可置换行内的和display属性为inline-block、inline-table的子元素，其垂直方向上的margin能够隔离自身与父元素； 在这里对margin合并和margin隔离作一个小结，本人把遇到过的所有在垂直方向上会发生与不会发生margin合并、能使用margin隔离与不能使用margin隔离的例子，都罗列了出来（然而这仅仅是在标准浏览器的例子，在IE6/7情况还会不一样，但因为现在基本无需再兼容低版本的IE，所以就不再列举）。目的不是让大家记住它，而是让大家避开它：在垂直方向上，兄弟元素间尽量不要设置相邻的margin，子元素也不要使用margin来隔离父元素，这样能尽量保证你的CSS代码，在各种版本的浏览器都有较好的兼容性（显示一致）。 结尾语本文从CSS盒模型及其发展史、元素的分类及其布局特性、格式化上下文(Formatting Context)、包含块、基本原理（文档流、浮动、清除浮动、定位、行框、margin）这五大模块，系统介绍了一下前端的布局基础，希望此次分享，能够让各位读者对前端基础布局有一个底层、体系的认识。因为内容涵盖过广，难免会有纰漏，还望见谅和指正。 此篇文章断断续续写了几个月，从年前写到年后，一方面是因为这个标题太大，含括的内容太多，需要慢慢梳理；一方面是文中要讲的东西，很多是出于本人的感悟和总结，为了保证观点的正确性、严谨性以及和行业的标准术语做好同步，需逐一验证；还有一方面也是近几个月来，本人需要处理的私事较多，分散了精力。 最后我还想再分享一些心得体会： 不要轻视简单的东西 我们在生活中总是容易忽略一些简单的东西，因为轻视简单，导致过了几年依然也没有掌握，前端的同学更应该注意这一点。 尽信书不如无书 不要太相信权威，而是要学会验证、总结，并构建自己的知识体系。 学技术要看官方文档 很多同学在初学时喜欢看一些快速入门的教程，我觉得这种学习习惯挺好的，但是建议不要遗漏官方文档的学习。因为初学者很难去鉴定一个非官方文档的质量，运气不好的话，还会被误导。而且官方文档最贴近原作者的想法，我们更容易体会到其设计思想。 演示代码地址]]></content>
      <categories>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[手机H5页面通用适配方案]]></title>
    <url>%2F2018%2F03%2F15%2F2018-03-15-%E6%89%8B%E6%9C%BAH5%E9%A1%B5%E9%9D%A2%E9%80%9A%E7%94%A8%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88%2F</url>
    <content type="text"><![CDATA[前言前段时间一堆App更新其中有一条原因就是适配iPhoneX。现在QA也逐渐也iPhoneX的bug给开发了，那如何去适配新机型呢？今日早读文章由腾讯ISUX分享,转载自微信公众号前端早读课。 正文 目前的 H5 页面可以分为通栏页面和非通栏页面两种，每种页面都可能有底部操作栏，具体如下： 通栏页面顶部通栏某些业务的一级页面多数使用了顶部通栏 banner 的效果，由于 iPhone X 在状态栏增加了24px的高度，对于现在通栏 banner 规范的内容区域会有遮挡情况。 解决方案：对于通栏页面在页面顶部增加一层高度44px的黑色适配层，整个页面往下挪44px。 这种做法虽然不符合苹果要求的设计规范，但由于短时间内更新全部 banner 的成本太高，可以先这样简单处理，后续再优化 banner 的设计展现。 底部 Tab 栏 / 操作栏有些页面使用了底部 Tab 栏 / 操作栏，由于 iPhone X 去掉了底部 Home 键，取而代之是34px高度的 Home Indicator ，对于目前的底部 Tab 栏 / 操作栏会造成一定的阻碍。 解决方案：在页面底部增加一层高度34px的适配层，将操作栏上移34px，颜色可以自定义。 非通栏页面底部 Tab 栏 / 操作栏原因同上，在底部有34px高度的 Home Indicator ，对于目前的底部 Tab 栏 / 操作栏会造成一定的阻碍操作。 解决方案：在页面底部增加一层高度34px的颜色块，将操作栏上移34px，颜色可以自定义。 关于安全区域这里可能有人会有疑问，为什么非通栏下的页面内容是通到底部的，而按钮却是在安全区域上方呢？ 这个问题涉及到安全区域，iOS11 和先前版本的不同之处在于，webview 比较重视安全区域了。这意味着，如果给页面元素设置 top: 0, 它会渲染在屏幕顶部的44px之下，也就是状态栏下面。如果给页面元素设置 bottom: 0, 它会渲染在屏幕底部的34px之上，也就是底部安全区域上面。 为了解决这个尴尬的情况，苹果公司给我们提供了一个设置 viewport 的 meta 标签的解决方案。 viewport 可以设置的选项就是 viewport-fit, 它有三个可选值： contain: The viewport should fully contain the web content. 可视窗口完全包含网页内容 cover: The web content should fully cover the viewport. 网页内容完全覆盖可视窗口 auto: The default value, 同contain的作用 通过给页面设置viewport-fit=cover，可以将页面的布局区域延伸到页面顶部和底部。 对于通栏页面，设置了viewport-fit的属性，发现会不生效，经过跟同事查看手 Q 源码后发现，终端对于 WebView 通栏的情况设置了UIScrollViewContentInsetAdjustmentNever属性，去除了上下安全区域的边距，使得安全区域的上下边距失效了。 另外提一点，经过 2 个版本的 webview 测试，发现 WKWebView 在渲染页面的时候，底部按钮在位置表现上不一致，可能是一个还未解决的 bug： 使用 web方案：根据以上的设计方案，可以这样处理： 修改页面 viewport-fit 属性 在 H5 页面链接一个 iphonex.css 来给 iPhone X 访问的页面增加对应的适配层 在 H5 页面上给对应的 dom 结构加上适配的类名 iPhoneX.css 如上，这样做的问题是，要修改的页面非常多，而且给页面带来了额外的类名，对以后的样式移除也有一定的工作量。 另外，使用样式给页面顶部增加适配层，下拉页面的时候黑色适配层会跟着一起移动： https://v.vzuu.com/video/911624446303952896 既然使用 web 的方式来解决这个问题不是很完美，是否可以通过终端的方式给 webview 增加适配层，从而解决这个问题呢？ 使用终端方案经过跟终端同学的沟通，确定是可以通过终端的方式，在原生界面初始化的时候增加适配层，这样页面就不需要样式处理了。 具体是通过链接中增加参数来进行适配: 参数名:_wvx 控制 iPhone X 适配行为 参数名:_wvxTclr 控制顶部适配层颜色 参数名:_wvxBclr 控制底部适配层颜色 对于顶部通栏的页面，通过加 URL 参数来增加顶部黑色适配层。 对于有底部操作栏（包括通栏和非通栏），通过加 URL 参数来增加底部适配层以及设置颜色。 （这里的 wvx=10 为 2 和 8 两个特性数字相加） 这样，无需写一行代码，只需要给页面链接增加适配参数，就可以完美适配 iPhone X 了~ 最后，为你推荐： 剖析 iOS 11网页适配问题 关于本文 作者：@腾讯 ISUX 社交用户体验设计中心 原文：https://zhuanlan.zhihu.com/p/30840440]]></content>
      <categories>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>手机端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CSS命名规范]]></title>
    <url>%2F2018%2F03%2F10%2F2018-03-10-CSS%E5%91%BD%E5%90%8D%E8%A7%84%E8%8C%83%2F</url>
    <content type="text"><![CDATA[前言上周快本上有一个90后作家说现在书比较受欢迎的书名格式是名字很长，中间还有一个逗号。你看今天这个符合90风格吗？今日文章由@unicar 翻译分享,转载自微信公众号前端早读课。 @unicar，从设计半路出家的前端er，现就职于悉尼一家startup。喜欢creative coding和开源硬件。 正文我听说很多开发者厌恶 CSS。而在我的经验中，这往往是由于他们并没有花时间来学习 CSS。 CSS 算不上是最优美的『语言』，但迄今二十多年来，它都是美化 web 举足轻重的工具。从这点来说，也还算不错吧？ 尽管如此，CSS 写得越多，你越容易发现一个巨大的弊端。 因为维护 CSS 真是老大难。 特别是那些写得差劲的 CSS 会很快变成程序员的噩梦。 这里向大家介绍一些命名规范，遵照这些规范可以省时省力，少走弯路。 使用连字符分隔的字符串如果你常写 JavaScript，那么你知道对变量使用驼峰式命名法（camel case）是一种惯例。 12var redBox = document.getElementById('...') 这样很好，对吧？ 但问题是这种命名法并不适用于 CSS。 请切忌以如下方式命名： 1234.redBox &#123; border: 1px solid red;&#125; 相应的，你可以这样写： 1234.red-box &#123; border: 1px solid red;&#125; 这是一种非常标准的 CSS 命名规范。也可以说更易读。 同时，这也和 CSS 属性名称保持了一致。 12345678910// Correct.some-class &#123; font-weight: 10em&#125;// Wrong.some-class &#123; fontWeight: 10em&#125; BEM 命名规范不一样的团队在写 CSS 选择器（CSS selectors）有不一样的方法。有些团队使用的是连字符分隔（hyphen delimiters）法，还有一些倾向于使用一种叫 BEM 的命名法，这种方法更加有条理。 总的来说，这些 CSS 命名规范试图解决 3 类问题： &emsp;&emsp; 1. 仅从名字就能知道一个 CSS选择器具体做什么&emsp;&emsp; 2. 从名字能大致清楚一个选择器可以在哪里使用&emsp;&emsp; 3. 从 CSS 类的名称可以看出它们之间的联系 不知你是否见过这样的类名： 12345678.nav--secondary &#123; ...&#125;.nav__header &#123; ...&#125; 这就是 BEM 命名规范。 向 5 岁小孩解释 BEM 规范BEM 规范试图将整个用户界面分解成一个个小的可重复使用的组件。 让我们来看看下图： 这可是个足以得奖的火柴人呢 :) 哎，可惜并不是 :( 这个火柴人代表了一个组件，比如说一个设计区块。 或许你已经猜到了 BEM 这里的 B 意为『区块』（‘Block’）。 在实际中，这里『区块』可以表示一个网站导航、页眉、页脚或者其他一些设计区块。 根据上述解释，那么这个组件的理想类名称即是 stick-man。 组件的样式应写成这样： 1234.stick-man &#123;&#125; 在这里我们使用了连字符分隔法，很好！ E 代表元素（Elements）BEM 中的 E 代表着元素。 整体的区块设计往往并不是孤立的。 比方说，这个火柴人有一个头部（head），两只漂亮的手臂（arms）和双脚（feet）。 这些 head、 feet 和 arms 都是组件中的元素。它们可视作子组件（child components），也就是父组件的组成部分。如果使用 BEM 命名规范的话，这些元素的类名都可以通过在两条下划线后加上元素名称来产生。 比如说： 123456789101112.stick-man__head &#123;&#125;.stick-man__arms &#123;&#125;.stick-man__feet &#123;&#125; M 代表修饰符（Modifiers）M 在 BEM 命名法中代表修饰符。 如果说这个火柴人有个 blue 或者 red 这样的修饰符怎么办呢？ 在现实场景里，这可能是一个 red 或者 blue 的按钮。这就是之前在讲的组件当中的限定修饰。 如果使用 BEM 的话，这些修饰符的类名都可以通过在两条连字符后加上元素名来产生。 比如说： 12345678.stick-man--blue &#123;&#125;.stick-man--red &#123;&#125; 最后这个例子展示的是父组件加修饰符。不过这种情况并不经常出现。 假如我们这个火柴人拥有另一个不一样的头部大小呢？ 这一次元素被加上了修饰符。记住，元素指一个整体封装区块中的一个子组件。 .stick-man 表示区块（Block）， .stick-man__head 表示元素（the element）。 从上例可以看出，双连字符也可以这样使用： 1234567.stick-man__head--small &#123;&#125;.stick-man__head--big &#123;&#125; 重申一次，上例中使用的双连字符是用来指代修饰符的。 这样你都明白了吧。 这就是 BEM 的基本用法。 个人来说，我在小项目中一般只用连字符分割法来写类名，在用户界面更复杂的项目中使用 BEM 方法 为何要使用命名规范？ 在计算机科学当中只有两类难题：缓存失效和命名 - Phil Karlton 命名的确很难。所以我们要尽量把它变得容易点，也为以后维护代码省点时间。 能正确命名 CSS 中的类名可以让你的代码变得更易理解和维护。 如果你选择 BEM 命名规范，在看标记语言（markup）时就更容易看清各个设计组件/区块之间的关系。 感觉不错吧？ 和 JavaScript 关联的 CSS 名称今天是 John 上班第一天。 他拿到了如下一段 HTML 代码： 1234&lt;div class="siteNavigation"&gt;&lt;/div&gt; 因为刚好读了这篇文章，John 意识到这种命名方法在 CSS 中不是最好的方法。于是他讲代码修改成下面这样： 1234&lt;div class="site-navigation"&gt;&lt;/div&gt; 看上去不错吧？ 不过 John 没想到的是，他把整个代码库搞砸了 😩😩😩 为什么会这样？ 在 JavaScript 代码中，有一段是和之前的类名 siteNavigation 有关联的： 1234// Javasript 代码const nav = document.querySelector('.siteNavigation') 由于类名的改变，nav 变量现在变成了 null。 好忧桑。😔😔 为了防止这种情况发生，开发者们想了很多不同的策略。 1. 使用 js- 类名一种减少这类 bug 的方法是使用 js-* 的类名命名方法。用这种方法来表明这个 DOM 元素和 JavaScript 代码的关联。 例如：1234&lt;div class="site-navigation js-site-navigation"&gt;&lt;/div&gt; 同样的在 JavaScript 代码中： 123//the Javasript codeconst nav = document.querySelector('.js-site-navigation') 依照命名规范，任何人看到 js- site-navigation 这个类名称，就会知道 JavaScript 代码中有一段和这个 DOM 元素有关联的代码。 2. 使用 Rel 属性我自己没用过这种方法，不过我看到其他人用过。 你是否熟悉这样的代码？ 12&lt;link rel="stylesheet" type="text/css" href="main.css"&gt; 一般来说，rel 属性 定义着链接资源和引用它的文件之间的关系。 回头看 John 的例子，这种方法建议我们写成如下的形式：1234&lt;div class="site-navigation" rel="js-site-navigation"&gt;&lt;/div&gt; 同时在 JavaScript 中： 12const nav = document.querySelector("[rel='js-site-navigation']") 我对这种方法持保留态度。不过你很可能在某些代码库中看到它们。这种方法就好像在说：“ 好吧，这里和 Javascript 有个关联，那么我就用 rel 属性来表示这种关联。 ” 互联网这个地方，解决同一个问题常常有无数种『方法』。 3. 别用数据属性（data attributes）有些开发者用数据属性（data attributes）作为 JavaScript 钩子。这是不对的。根据定义，data 属性（data attributes）是用来 储存自定义数据（to store custom data） 的。 这里数据属性（data attributes）用得很妙。正如这条 Twitter 上所说的。 ####附加提议：写更多的 CSS 注释 这跟命名规范毫无关系，但也能帮你节省时间。 尽管很多 web 开发者尽量不写 Javascript 评论或者只针对某些情况才写，但我认为你应该写更多的 CSS 注释。 这是因为 CSS 不是最简洁优雅的『语言』，有条理的注释可以让你花更少时间来理解自己的代码。 有益无弊，何乐不为。 你可以看看 Bootstrap 的注释写得有多好。 你倒不需要写一个 color: red 的注释告诉自己这是把颜色定为红色。但如果你用了一个不太简单明了的 CSS 小技巧，这时候大可以写写注释说明一下。]]></content>
      <categories>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[响应式布局]]></title>
    <url>%2F2018%2F03%2F09%2F2018-03-09-%E5%93%8D%E5%BA%94%E5%BC%8FWeb%E8%AE%BE%E8%AE%A1%E7%9A%84%E5%9F%BA%E6%9C%AC%E5%8E%9F%E5%88%99%2F</url>
    <content type="text"><![CDATA[前言响应式web设计对于解决多类型屏幕问题来说是个不错方案，但从印刷的角度来看，其却存在着很多的困难。没有固定的页面尺寸、没有毫米或英寸，没有任何物理限制，让人感到无从下手。随着建立网站可用的各种小工具越来越多，像素设计局限于桌面和移动端也已经成为历史。因此，现在就让我们来说明一下如何运用响应式web设计的各项基本原则来实现，而不是抗拒流畅的网页体验。为了简单起见，我们将着重讲布局（当然，响应式设计远远不止于此）。 正文响应式设计vs适应式设计看似相同实则不然。这两种设计方式彼此相辅相成，所以说也没有对错之分。具体情况要依内容而定。 内容流随着屏幕尺寸越来越小，内容所占的垂直空间也越来越多，也就是说，内容会向下方延伸，这就叫做内容流。如果你习惯了使用像素和点进行设计，可能会觉得这个有点难掌握。不过没关系，习惯了就很好理解了。 相对单位你的设计对象可能是台式桌面，也可能是移动端屏幕或者介于两者之间的任意屏幕类型。像素密度也会彼此不同，所以我们需要使用灵活可变，并且能够适应各种情况的单位。那么在这种情况下，百分比等相对单位就派上用场了。使用百分比时，我们说宽度50%就是表示宽度占屏幕大小（或者叫视区，也就是指所打开浏览器窗口的大小）的一半。 断点断点可以让页面布局在预设的点进行变形，也就是说，在台式桌面上显示3栏，在移动设备上仅显示1栏。大多数CSS属性都可以实现断点之间的变形。断点放置的位置通常取决于内容。比如，如果一句话要换行，你可能就需要加上断点。但断点使用时需要谨慎——如果搞不清内容之间的逻辑关系，很容易弄的一团乱。 最大和最小值有时候内容占满整个屏幕宽度（例如在移动设备上）是好事，但如果相同的内容在电视屏幕上也撑得满满的，貌似就不太合理了。这就是为什么要有最大/最小值。例如，如果宽度为100%，最大宽度1000px，那么内容就会以不超过1000px的宽度填充屏幕。 嵌套对象还记得相对位置吗？如果一大堆要素彼此都紧密联系，那么必将难以控制。因此，将要素放置到容器中就会让它们变得更加好理解，并且简洁明快。这种情况就需要用到像素之类的静态单位了。静态单位对于logo和按钮等不需要扩展的内容来说非常有用。 移动优先还是台式桌面优先严格来说，项目从小屏幕入手过渡到大屏幕（移动优先），还是从大屏幕入手过渡到小屏幕（台式桌面优先）区别不大。但是，从移动端着手可以给你带来一些额外的限制，帮助你进行决策。通常情况下大家会从两方面同时着手，所以你还是要看哪种方式最适合你。 web字体vs系统字体想让自己的网站拥有炫酷的Futura或Didot效果吗？那就是用web字体吧。尽管web字体看起来很炫酷，但你要记住，这些字体都需要用户下载，字越多，用户加载页面的时间也就越长。另一方面，系统字体加载速度则快得多（前提是用户本机就有），但太过普通。 位图vs矢量图你的图标是否有很多细节，并且应用了很多华丽的效果？如果是，那就用位图。如果不是，考虑使用矢量图。如果是位图，使用jpg、png或gif。矢量图则最好使用SVG或图标字体。其各有利弊。但你要时刻牢记图标尺寸——未经过优化的图片不能传到网上。另一方面，矢量图通常比较小，不过部分比较老的浏览器可能不支持矢量图。还有，如果图标有很多曲线，那有可能会比位图还大，所以要明智取舍。]]></content>
      <categories>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>CSS</tag>
      </tags>
  </entry>
</search>
